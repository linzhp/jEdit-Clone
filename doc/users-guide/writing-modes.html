<!DOCTYPE HTML PUBLIC "-//Norman Walsh//DTD DocBook HTML 1.0//EN">
<HTML
><HEAD
><TITLE
>Writing Edit Modes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet"><LINK
REL="HOME"
TITLE="jEdit 2.5 User's Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Edit Modes"
HREF="modes.html"><LINK
REL="PREVIOUS"
TITLE="Installing New Edit Modes"
HREF="installing-modes.html"><LINK
REL="NEXT"
TITLE="Source Code Editing"
HREF="source-edit.html"></HEAD
><BODY
BGCOLOR="#FFFFFF"
><DIV
CLASS="NAVHEADER"
><H1
>jEdit 2.5 User's Guide</H1
><P
><A
HREF="source-edit.html"
>Next</A
>, <A
HREF="installing-modes.html"
>Prev</A
></P
><H2
>Chapter 5. Edit Modes</H2
><HR></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WRITING-MODES"
>Writing Edit Modes</A
></H1
><P
>   In jEdit versions prior to 2.4, each syntax highlighting mode was
   actually a Java class known as a <I
CLASS="FIRSTTERM"
>token
   marker</I
>. Token markers required a good knowledge of Java to write,
   and were tricky to debug. In jEdit 2.4, Mike Dillon's XMode plugin
   was integrated into the core. XMode is a generic
   syntax parser that reads
   highlighting rules from XML files. XML files are much easier to
   write, change and debug than token markers.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1488"
>An XML Primer</A
></H2
><P
>    XML is a simplified version of SGML, which is a language closely
    related to HTML. Because of this, XML looks very similar to HTML
    and anyone who's done a bit of web page authoring will immediately
    pick it up.
  </P
><P
>   Here is a sample XML file that also happens to be a definition for
   a (useless) edit mode called "my-mode":
  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE NAME="my-mode"&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="label" VALUE="My First Edit Mode" /&gt;
        &lt;PROPERTY NAME="filenameGlob" VALUE="*.my" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES&gt;
        &lt;!- - syntax highlighting rules go here - -&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</PRE
></TD
></TR
></TABLE
><P
>   If you're familiar with HTML, keep the following in mind when writing XML:
  </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>&lt;? xml version="1.0"?&gt;</SPAN
> - strings
   enclosed with "&lt;?" and "?&gt;" are called
   <I
CLASS="FIRSTTERM"
>processing instructions</I
>. The only processing instruction
   that you need to know to write edit modes is one that specifies the
   XML version.</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;</SPAN
> - tags
   beginning with "&lt;!" give extra information to the parser.
   This <SPAN
CLASS="MARKUP"
>DOCTYPE</SPAN
> declaration tells the
   parser that the following XML document is of type "MODE".
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>&lt;PROPERTY NAME="label" VALUE="My First Edit Mode" /&gt;</SPAN
> - 
   unlike HTML, where some tags stand on their own (<SPAN
CLASS="MARKUP"
>IMG</SPAN
>, for
   example) <I
CLASS="EMPHASIS"
>all tags must be closed</I
> in XML. Even if a
   there is nothing between the opening and closing tags, they must
   still be specified. To avoid clutter, the XML standard specifies
   that <SPAN
CLASS="MARKUP"
>&lt;<TT
CLASS="REPLACEABLE"
><I
>TAG</I
></TT
> /&gt;</SPAN
> is the same as
   <SPAN
CLASS="MARKUP"
>&lt;<TT
CLASS="REPLACEABLE"
><I
>TAG&gt;</I
></TT
>&lt;/<TT
CLASS="REPLACEABLE"
><I
>TAG&gt;</I
></TT
></SPAN
>.
   </P
></LI
><LI
><P
>All attribute values must be quoted. In HTML, you can
   get away with writing <SPAN
CLASS="MARKUP"
>NAME=label</SPAN
> inside a tag; in XML,
   you must write <SPAN
CLASS="MARKUP"
>NAME="label"</SPAN
>.
   </P
></LI
><LI
><P
>XML is case sensitive. <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> is not the same
   as <SPAN
CLASS="MARKUP"
>Span</SPAN
> or <SPAN
CLASS="MARKUP"
>span</SPAN
>.</P
></LI
></UL
><P
>   To insert a special character such as &lt; or &gt; literally in XML
   (for example, inside an attribute value), you must write it as
   an <I
CLASS="FIRSTTERM"
>entity</I
>. An
   entity consists of the character's symbolic name enclosed with
   "&amp;" and ";". A full list of entities is out of
   the scope of this chapter, but the most important are:
  </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>&amp;lt;</SPAN
> - The less-than (&lt;) character</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>&amp;gt;</SPAN
> - The greater-than (&gt;) character</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>&amp;amp;</SPAN
> - The ampersand (&amp;) character</P
></LI
></UL
><P
>   For example, to highlight "&lt;" as an <TT
CLASS="CLASSNAME"
>OPERATOR</TT
> in
   Java mode, you can't write "&lt;SEQ TYPE="OPERATOR"&gt;&lt; &lt;/SEQ&gt;"
   because that would cause a syntax error. Instead, you must write:
  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;</PRE
></TD
></TR
></TABLE
><P
>   Now that you know the basics of XML, read on to find out how to write
   edit modes.
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1557"
>The Preamble</A
></H2
><P
>    Each mode definition must start with the following:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1564"
>The MODE Tag</A
></H2
><P
>    Each mode definition must contain at least one <SPAN
CLASS="MARKUP"
>MODE</SPAN
>
    tag. All other tags (<SPAN
CLASS="MARKUP"
>PROPS</SPAN
>, <SPAN
CLASS="MARKUP"
>RULES</SPAN
>) must be
    placed inside the <SPAN
CLASS="MARKUP"
>MODE</SPAN
> tag.
    The mode tag has one required attribute, <SPAN
CLASS="MARKUP"
>NAME</SPAN
>. It must
    be set to the edit mode's name. The <SPAN
CLASS="MARKUP"
>MODE</SPAN
> tag for
    Java mode looks as follows:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;MODE NAME="java"&gt;
    &lt;!- - definition for Java mode goes here - -&gt;
&lt;/MODE&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1581"
>The PROPS Tag</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>PROPS</SPAN
> tag and the <SPAN
CLASS="MARKUP"
>PROPERTY</SPAN
> tags inside it
    are used to define mode-specific
    properties. Each <SPAN
CLASS="MARKUP"
>PROPERTY</SPAN
> tag must have a
    <SPAN
CLASS="MARKUP"
>NAME</SPAN
> attribute set to the property's name, and a
    <SPAN
CLASS="MARKUP"
>VALUE</SPAN
> attribute with the property's value.
   </P
><P
>    In addition to the properties listed in <A
HREF="buffer-local.html"
>the section called <I
>Buffer-Local Properties</I
> in Chapter 8</A
>,
    you can use the following properties in modes:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="PROPERTY"
>label</SPAN
> - this property must be specified. It is
    the full name of the edit mode, for example "MS-DOS Batch File".
    </P
></LI
><LI
><P
><SPAN
CLASS="PROPERTY"
>filenameGlob</SPAN
> - if a file's name matches this
    glob pattern, it will be opened with this edit mode. See
    <A
HREF="globs.html"
>Appendix D</A
> for information about glob patterns.
    In Java mode, for example, the value of this property is
    "*.java".
    </P
></LI
><LI
><P
><SPAN
CLASS="PROPERTY"
>firstlineGlob</SPAN
> - similar to
    <SPAN
CLASS="PROPERTY"
>filenameGlob</SPAN
>, except that it is applied to a buffer's
    first line, instead of file name. In Perl mode, for example,
    the value of this property is "#!/*perl*".
    </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1618"
>The RULES Tag</A
></H2
><P
>    <SPAN
CLASS="MARKUP"
>RULES</SPAN
> tags must be placed inside the <SPAN
CLASS="MARKUP"
>MODE</SPAN
> tag.
    Each <SPAN
CLASS="MARKUP"
>RULES</SPAN
> tag defines a <I
CLASS="FIRSTTERM"
>ruleset</I
>.
    A ruleset
    consists of a number of <I
CLASS="FIRSTTERM"
>parser rules</I
>, with each parser
    rule specifying how to highlight a specific syntax token. There must
    be at least one ruleset in each edit mode. There can also be more
    than one, with different rulesets being used to highlight different
    parts of a buffer (for example, in HTML mode, different rulesets are used to
    highlight
    tags and inline JavaScript). For information about using more
    than one ruleset, see <A
HREF="writing-modes.html#SPAN"
>the section called <I
>SPAN rule</I
></A
>.
   </P
><P
>    The <SPAN
CLASS="MARKUP"
>RULES</SPAN
> tag supports the following attributes, all of
    which are optional:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>HIGHLIGHT_DIGITS</SPAN
> - if set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, digits (0-9, as well as hexadecimal literals
    prefixed with "0x") will be highlighted with the
    <TT
CLASS="CLASSNAME"
>DIGIT</TT
> token type. Default is <SPAN
CLASS="MARKUP"
>FALSE</SPAN
>.
    </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>IGNORE_CASE</SPAN
> - if set to
    <SPAN
CLASS="MARKUP"
>FALSE</SPAN
>, matches will be case sensitive. Otherwise, case will not
    matter.
    Default is <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>.
    </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>DEFAULT</SPAN
> - the token type for
    text which doesn't match
    any specific rule. Default is <SPAN
CLASS="MARKUP"
>NULL</SPAN
>. See
    <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types.
    </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>SET</SPAN
> - the name of this ruleset.
    All rulesets other than the first must have a name.
    </P
></LI
></UL
><P
>    Each child element of the <SPAN
CLASS="MARKUP"
>RULES</SPAN
> tag defines a parser rule.
    Rules are checked in order; that means that if you define a
    rule that matches on "h" and another subsequent rule
    that matches on "hello", the "h" rule will handle
    all cases before the "hello" rule gets a chance.
    For the ruleset to work correctly, you must instead 
    place the "hello" rule before the
    "h" one.
   </P
><P
>    Here is an example <SPAN
CLASS="MARKUP"
>RULES</SPAN
> tag:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
    <TT
CLASS="REPLACEABLE"
><I
>...</I
></TT
>
&lt;/RULES&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1677"
>TERMINATE rule</A
></H2
><P
>    There can only be one <SPAN
CLASS="MARKUP"
>TERMINATE</SPAN
> tag per ruleset.
    The <SPAN
CLASS="MARKUP"
>TERMINATE</SPAN
> rule specifies that parsing should stop after
    the specified number of characters have been read from a line. The
    number of characters to terminate after can be specified with the
    <SPAN
CLASS="MARKUP"
>AT_CHAR</SPAN
> attribute. This is
    used in patch mode, for example, because only the first character
    of each line affects highlighting. Here is an example:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;TERMINATE AT_CHAR="1" /&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1690"
>WHITESPACE rule</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>WHITESPACE</SPAN
> rule specifies characters which are to
    be treated as whitespace; in other words, keyword delimiters.
    Most rulesets will have <SPAN
CLASS="MARKUP"
>WHITESPACE</SPAN
> tags for spaces and
    tabs. Here is an example:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;WHITESPACE&gt; &lt;/WHITESPACE&gt;
&lt;WHITESPACE&gt;        &lt;/WHITESPACE&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPAN"
>SPAN rule</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> rule highlights ranges of text between a start
    and end string. The start and end strings are specified inside
    child elements of the <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> tag, like so:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SPAN TYPE="COMMENT1"&gt;
    &lt;BEGIN&gt;/*&lt;/BEGIN&gt;
    &lt;END&gt;*/&lt;/END&gt;
&lt;/SPAN&gt;</PRE
></TD
></TR
></TABLE
><P
>    The following attributes are supported:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>TYPE</SPAN
> - The token type to highlight the span
    with. See <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>AT_LINE_START</SPAN
> - If set to <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>,
    the span will only be highlighted if the start sequence occurs at the
    beginning of a line</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>EXCLUDE_MATCH</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the start and end sequences will not be highlighted,
    only the text between them will</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>NO_LINE_BREAK</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the span will be highlighted with the <TT
CLASS="CLASSNAME"
>INVALID</TT
>
    token type if it spans more than one line</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>NO_WORD_BREAK</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the span will be highlighted with the <TT
CLASS="CLASSNAME"
>INVALID</TT
>
    token type if it includes whitespace</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>DELEGATE</SPAN
> - text inside the span will be
    highlighted with the specified ruleset. To delegate to a ruleset defined
    in the current mode, just specify its name. To delegate to a ruleset
    defined in another mode, specify a name of the form
    <SPAN
CLASS="MARKUP"
><TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>::<TT
CLASS="REPLACEABLE"
><I
>ruleset</I
></TT
></SPAN
>.
    Note that the first (unnamed) ruleset in a mode is called
    "MAIN".</P
></LI
></UL
><P
>    Here is a <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> that highlights Java string literals,
    which cannot include line breaks:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;</PRE
></TD
></TR
></TABLE
><P
>    Here is a <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> that highlights Java documentation comments
    by delegating to the "JAVADOC" ruleset defined elsewhere
    in the current mode:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SPAN TYPE="COMMENT2" DELEGATE="JAVADOC"&gt;
    &lt;BEGIN&gt;/**&lt;/BEGIN&gt;
    &lt;END&gt;*/&lt;/END&gt;
&lt;/SPAN&gt;</PRE
></TD
></TR
></TABLE
><P
>    Here is a <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> that highlights HTML cascading stylesheets inside
    <SPAN
CLASS="MARKUP"
>STYLE</SPAN
> tags by delegating to the CSS ruleset in another mode:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SPAN TYPE="MARKUP" DELEGATE="css::MAIN"&gt;
    &lt;BEGIN&gt;&amp;lt;style&amp;gt;&lt;/BEGIN&gt;
    &lt;END&gt;&amp;lt;/style&amp;gt;&lt;/END&gt;
&lt;/SPAN&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1774"
>EOL_SPAN rule</A
></H2
><P
>    An <SPAN
CLASS="MARKUP"
>EOL_SPAN</SPAN
> is similar to a <SPAN
CLASS="MARKUP"
>SPAN</SPAN
> except that
    highlighting stops at the end of the line, not after the end sequence
    is found. The text to match is specified between the opening and closing
    <SPAN
CLASS="MARKUP"
>EOL_SPAN</SPAN
> tags.
    The following attributes are supported:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>TYPE</SPAN
> - The token type to highlight the span
    with. See <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>AT_LINE_START</SPAN
> - If set to <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>,
    the span will only be highlighted if the start sequence occurs at the
    beginning of a line</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>EXCLUDE_MATCH</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the start sequence will not be highlighted,
    only the text after it will</P
></LI
></UL
><P
>    Here is an <SPAN
CLASS="MARKUP"
>EOL_SPAN</SPAN
> that highlights C++-style comments:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;EOL_SPAN TYPE="COMMENT1"&gt;//&lt;/EOL_SPAN&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1808"
>MARK_PREVIOUS rule</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>MARK_PREVIOUS</SPAN
> rule highlights from the end of the
    previous syntax token to the matched text. The text to match
    is specified between opening and closing <SPAN
CLASS="MARKUP"
>MARK_PREVIOUS</SPAN
>
    tags. The following attributes are supported:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>TYPE</SPAN
> - The token type to highlight the text
    with. See <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>AT_LINE_START</SPAN
> - If set to <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>,
    the text will only be highlighted if it occurs at the beginning of
    the line</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>EXCLUDE_MATCH</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the match will not be highlighted,
    only the text before it will</P
></LI
></UL
><P
>    Here is a rule that highlights labels in Java mode ("XXX:"):
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;MARK_PREVIOUS AT_LINE_START="TRUE"
    EXCLUDE_MATCH="TRUE"&gt;:&lt;/MARK_PREVIOUS&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1841"
>MARK_FOLLOWING rule</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>MARK_FOLLOWING</SPAN
> rule highlights from the start of the
    match to the next syntax token or white space. The text to match
    is specified between opening and closing <SPAN
CLASS="MARKUP"
>MARK_FOLLOWING</SPAN
>
    tags. The following attributes are supported:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>TYPE</SPAN
> - The token type to highlight the text
    with. See <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>AT_LINE_START</SPAN
> - If set to <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>,
    the text will only be highlighted if the start sequence occurs at the
    beginning of a line</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>EXCLUDE_MATCH</SPAN
> - If set to
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>, the match will not be highlighted,
    only the text after it will</P
></LI
></UL
><P
>    Here is a rule that highlights variables in Unix shell scripts
    ("$CLASSPATH", "$IFS", etc):
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;MARK_FOLLOWING TYPE="KEYWORD2"&gt;$&lt;/MARK_FOLLOWING&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1875"
>SEQ rule</A
></H2
><P
>    The <SPAN
CLASS="MARKUP"
>SEQ</SPAN
> rule highlights fixed sequences of text. The text
    to highlight is specified between opening and closing <SPAN
CLASS="MARKUP"
>SEQ</SPAN
>
    tags. The following attributes are supported:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>TYPE</SPAN
> - the token type to highlight the
    sequence with. See <A
HREF="writing-modes.html#TOKENS"
>the section called <I
>Token Types</I
></A
> for a list of token types</P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>AT_LINE_START</SPAN
> - If set to <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>,
    the sequence will only be highlighted if if it occurs at the
    beginning of a line</P
></LI
></UL
><P
>    The following <SPAN
CLASS="MARKUP"
>SEQ</SPAN
>s highlight a few Java operators:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1901"
>KEYWORDS rule</A
></H2
><P
>    There can only be one <SPAN
CLASS="MARKUP"
>KEYWORDS</SPAN
> tag per ruleset.
    The <SPAN
CLASS="MARKUP"
>KEYWORDS</SPAN
> rule allows you to define keywords to highlight.
    Keywords are similar to <SPAN
CLASS="MARKUP"
>SEQ</SPAN
>s, except that <SPAN
CLASS="MARKUP"
>SEQ</SPAN
>s
    match anywhere in the text, whereas keywords only match whole words.
   </P
><P
>    The <SPAN
CLASS="MARKUP"
>KEYWORDS</SPAN
> tag supports only one attribute,
    <SPAN
CLASS="MARKUP"
>IGNORE_CASE</SPAN
>. If set to <SPAN
CLASS="MARKUP"
>FALSE</SPAN
>, keywords will be
    case sensitive. Otherwise, case will not matter. Default is
    <SPAN
CLASS="MARKUP"
>TRUE</SPAN
>.
   </P
><P
>    Each child element of the <SPAN
CLASS="MARKUP"
>KEYWORDS</SPAN
> tag should be named after the
    desired token type, with the keyword text between the start and end tags.
    For example, to highlight the most common Java keywords, you would write:
   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&lt;KEYWORDS IGNORE_CASE="FALSE"&gt;
    &lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
    &lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
    &lt;KEYWORD3&gt;int&lt;/KEYWORD3&gt;
    &lt;KEYWORD3&gt;char&lt;/KEYWORD3&gt;
&lt;/KEYWORDS&gt;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="TOKENS"
>Token Types</A
></H2
><P
>    Each syntax token is of one of the following types:
   </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="MARKUP"
>NULL</SPAN
> (this is the default type. No special
   highlighting is performed on tokens of type <SPAN
CLASS="MARKUP"
>NULL</SPAN
>)
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>COMMENT1</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>COMMENT2</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>DIGIT</SPAN
> (tokens of this type are automatically
   added if the <SPAN
CLASS="MARKUP"
>HIGHLIGHT_DIGITS</SPAN
> attribute of a ruleset is set;
   you should not explicitly define rules with this token type)
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>FUNCTION</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>INVALID</SPAN
> (tokens of this type are automatically
   added when an invalid sequence of characters is found; you should not
   explicitly define rules with this token type)
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>KEYWORD1</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>KEYWORD2</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>KEYWORD3</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>LABEL</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>LITERAL1</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>LITERAL2</SPAN
>
   </P
></LI
><LI
><P
><SPAN
CLASS="MARKUP"
>OPERATOR</SPAN
>
   </P
></LI
></UL
><P
>    There are no formal conventions specifying which token types should be
    used for what; instead, just take a look at how syntax is highlighted
    in some existing modes and
    decide for yourself what token type you should use.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR><A
HREF="index.html"
>Home</A
>, <A
HREF="modes.html"
>Up</A
><BR><A
HREF="installing-modes.html"
>Prev</A
>: Installing New Edit Modes<BR><A
HREF="source-edit.html"
>Next</A
>: Source Code Editing<BR></DIV
></BODY
></HTML
>