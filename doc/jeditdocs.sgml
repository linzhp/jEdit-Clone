<!-- jEdit documentation, (C) 1999, 2000 Slava Pestov -->
<!-- Released under the GNU General Public License; see COPYING.txt -->

<!-- jEdit buffer-local properties: -->
<!-- :tabSize=1:noTabs=yes: -->

<!DOCTYPE book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [
<!ENTITY index.sgml SYSTEM "index.sgml">
]>
<book>

<!-- General information -->
<bookinfo>
 <title>jEdit 2.3 User's Guide</>
 <author><firstname>Slava</><surname>Pestov</></author>
 <legalnotice><title>Legal Notice</>
  <para>
   This book is released under the GNU General Public License. A copy
   of the GPL is available in the <filename>COPYING.txt</> file
   supplied with jEdit.
  </para>
 </legalnotice>
 <copyright><year>1999, 2000</year><holder>Slava Pestov</holder></copyright>
</bookinfo>

<chapter id=general-info><title>General Information</title>
 <sect1 id=about-jedit><title>About jEdit</title>
  <para>
   Thanks for obtaining a copy of jEdit, a text
   editor written in Java. I hope you find it useful.
  </para>
  <para>
   The jEdit homepage, located at <ulink
   url="http://www.gjt.org/~sp/jedit.html">
   http://www.gjt.org/~sp/jedit.html</>
   contains the latest version of jEdit, along with plugin downloads.
  </para><para>
   
There are three mailing lists dedicated to jEdit; an announcement
list that is very low traffic, a general discussion list, and a
development discussion list. To subscribe, unsubscribe or view
a list archive, visit <ulink
url="http://www.sourceforge.net/mail/?group_id=588">
http://www.sourceforge.net/mail/?group_id=588</>.
</para><para>
  Finally, you may contact me directly by e-mailing <email>sp@gjt.org</>.
  </para>
 </sect1>
 <sect1 id=licensing><title>Licensing Information</>
  <para>
   jEdit is released under the GNU General Public License, which can be
   found in the <filename>COPYING.txt</> file of the jEdit distribution.
  </para>
  <para>
   jEdit comes with ABSOLUTELY NO WARRANTY OF ANY KIND; see
   section 11 and 12 of the GPL for details.
   </para>
 </sect1>
 <sect1 id=release-notes><title>Release Notes</>
  <para>
   The following is an overview of the major changes in jEdit 2.3 since
   2.2. A complete list can be found in the file named
   <filename>CHANGES.txt</>, which is part of the jEdit distribution.
  </para>
 </sect1>
 <sect1 id=features><title>jEdit Features</>
  <para>
   The current version of jEdit has many features, the most important being
   the following:
  </para>
  <itemizedlist>
   <listitem><para>
    Syntax highlighting of language tokens using colors and styles
   </para></listitem>
   <listitem><para>
    Automatic indentation and support for soft tabs
   </para></listitem>
   <listitem><para>
    Bracket matching and highlighting
   </para></listitem>
   <listitem><para>
    Keyboard macros and repeating commands for automating complex and
    frequently performed operations
   </para></listitem>
   <listitem><para>
    Any number of <quote>registers</> can be used to store text strings and
    caret positions
   </para></listitem>
   <listitem><para>
    Rectangular selections, for working with columns of text
   </para></listitem>
   <listitem><para>
    Powerful search and replace that supports multi-file searching
    (including recursive directory search)
    and regular expressions (matching inexact sequences of text)
   </para></listitem>
   <listitem><para>
    HyperSearch feature that shows all lines in the document that
    contain a specified string
   </para></listitem>
   <listitem><para>
    A variety of commands for working with words, lines and paragraphs
   </para></listitem>
   <listitem><para>
    Support for files with Unix, Windows and MacOS line separators
   </para></listitem>
   <listitem><para>
    <quote>Markers</> can be used to rapidly move around long documents
   </para></listitem>
   <listitem><para>
    Comprehensive plugin system
   </para></listitem>
  </itemizedlist>
 </sect1>
</chapter>

<chapter id=conventions><title>Conventions Used in This Manual</title>
 <para>
  Various concepts are presented in a certain way in this manual.
  This chapter overviews the conventions used.
 </para>
 <sect1 id=menu-items><title>Menu Items</>
  <indexterm><primary>menu bar</></indexterm>
  <para>
   Because jEdit's menu hierarchy is rather complicated at times, the
   following convention is used to present menu items. First of all, the
   top level menu is listed, followed by successive levels of submenus,
   followed by the menu item itself. All menu components are separated
   by greater-than symbols (<quote>&gt;</>). For example,
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Indent
   Selected Lines</> refers to the <guimenuitem>Indent Selected Lines</>
   item of the
   <guisubmenu>Lines</> submenu of the <guimenu>Edit</> menu.
  </para>
  <para>
   Menu items that end with an ellipsis (...) display a dialog
   box, and usually provide an option to cancel.
   Other menu items take effect immediately (but they may possibly
   show alerts or errors).
  </para>
 </sect1>
 <sect1 id=shortcuts><title>Keyboard Shortcuts</>
  <indexterm><primary>keyboard shortcuts</><secondary>
  multiple keystroke</></indexterm>
  <para>
   In jEdit, most operations can be performed from the keyboard.
   Because there are quite a few commands, it would be very difficult to
   make them all accessible with one keystroke. So jEdit supports
   multiple keystroke bindings. To invoke a command with a multiple
   keystroke binding, all keystrokes have to be pressed, in order,
   with nothing in between.
  </para>
  <para>
   In this manual, key bindings are written in the form
   <keycombo><keycap>Modifier</><keycap>Key</></keycombo>, where
   <keycap>Modifier</> is the modifier key that must be pressed in
   addition to <keycap>Key</> to invoke that command. When multiple
   keystrokes are present in a binding, they will be listed in order,
   for example the shortcut for <guimenuitem>Indent Selected Lines</> is
   <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>I</></keycombo>.
  </para>
 </sect1>
</chapter>
<chapter id=basic-file-ops><title>Basic File Operations</>
 <para>
  This chapter describes jEdit's basic file-related operations, such as
  opening, saving, printing, and so on.
 </para>
 <sect1 id=starting><title>Starting jEdit</>
  <indexterm><primary>command line</></indexterm>
  <indexterm><primary>editor window</></indexterm>
  <indexterm><primary>sessions</></indexterm>
  <indexterm><primary>keyboard shortcuts</>
  <secondary>for accessing the menu bar</></indexterm>
  <para>
   Exactly how jEdit is started depends on the operating system;
   most often you would type <quote>jedit</quote> at the command line
   or double click on the jEdit icon (or select it from a menu,
   or whatever). Once started, it will display a <quote>splash
   screen</> with the jEdit logo and a progress bar that advances
   while jEdit loads. After a short delay, the editor window will
   appear.
   </para>
  <note>
   <para>
    jEdit accepts various command line parameters; see
    <xref linkend=cli-usage>.
   </para>
  </note>
  <tip>
   <para>
    When started with no file names on the command line, jEdit will
    open any files that were open in the previous session; see
    <xref linkend=sessions> for details.
    </para>
  </tip>
  <figure><title>The editor window</title>
   <graphic scale=75 fileref=window-editor></>
  </figure>
  <sect2 id=menubar><title>The Menu Bar</>
   <indexterm><primary>menu bar</></indexterm>
   <indexterm><primary>File menu</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <indexterm><primary>Utilities menu</></indexterm>
   <indexterm><primary>Macros menu</></indexterm>
   <indexterm><primary>Search menu</></indexterm>
   <indexterm><primary>Plugins menu</></indexterm>
   <para>
    The labels that run across
    the top of the editor window are called <firstterm>menus</>. Generally,
    <guimenu>File</> contains global file-related commands,
    <guimenu>Edit</> contains editing commands, and
    <guimenu>Utilities</> contains miscellaneous commands.
    <guimenu>Search</> and <guimenu>Macros</>
    contain commands for the respective jEdit features.
    <guimenu>Plugins</> contains menus and menu items created
    by plugins.
    </para>
   <para>
    Pressing <keycap>Alt</> in addition to an underlined character in the
    menu bar will display the respective menu. Once a menu is open,
    <keycap>Alt</> in addition to an underlined character in a menu item
    label will invoke that menu item as if it was selected with the mouse,
    and the arrow keys can be used to navigate the menu bar;
    <keycap>Left Arrow</> and <keycap>Right Arrow</> open the previous
    and next menu, respectively, and <keycap>Up Arrow</> and <keycap>Down Arrow</>
    move up and down the currently open menu.
   </para>
  </sect2>
  <sect2 id=toolbar><title>The Tool Bar</>
   <indexterm><primary>tool bar</></indexterm>
   <indexterm><primary>tool tips</></indexterm>
   <para>
    The strip of buttons underneath the menu bar is called the
    <firstterm>tool bar</>. Moving the mouse pointer over a
    button and holding it still will display a
    <firstterm>tooltip</> - a brief description of the button.
   </para>
   <figure><title>A tooltip</>
    <graphic scale=75 fileref=window-editor-tooltip></>
   </figure>
   <para>
    The text field labelled <quote>Find</> on the tool bar can be used
    to quickly search for a string without displaying the
    Search and Replace dialog box.
   </para>
   <tip>
    <para>
     If you don't use the tool bar, disable it in the
     <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box to save
     memory and startup time (the images won't be loaded if it is disabled).
    </para>
   </tip>
  </sect2>
  <sect2 id=textarea><title>The Text Area</>
   <indexterm><primary>text area</></indexterm>
   <indexterm><primary>caret</></indexterm>
   <indexterm><primary>scrolling</></indexterm>
   <indexterm><primary>current line highlighting</></indexterm>
   <indexterm><primary>line highlighting</></indexterm>
   <indexterm><primary>end of line markers</></indexterm>
   <indexterm><primary>invalid lines</></indexterm>
   <indexterm><primary>context menu</></indexterm>
   <indexterm><primary>right-click menu</></indexterm>
   <indexterm><primary>electric scrolling</></indexterm>
   <para>
    Most of the editor window is occupied by the text area. The text area
    displays the contents of the currently opened buffer.
    The two scroll bars can be used to move around the buffer when there
    is more text than can fit on the screen. The blinking red line
    is called the <firstterm>caret</firstterm>. Most text editing commands
    operate on the text at the caret.
   </para>
   <para>
    Notice how the line with the caret is highlighted, and a
    faint blue dot appears at the end of each line. The current line highlighting
    aids in locating the caret, and the dot is an <firstterm>end of
    line marker</>.
   </para>
   <para>
    The lines painted with red tildes (<quote>~</quote>)
    are <firstterm>invalid lines</firstterm> - they are visible for one
    reason or another,
    but don't actually exist in the document.
   </para>
   <para>
    The text area never allows the caret to be positioned in the first or
    last visible line. If It is moved closer than 3 lines to the top or
    bottom, the viewscreen will shift in the appropriate direction to
    make 3 lines above and below the caret
    visible. Having some <quote>context</> always visible helps when
    programming, for example. This feature
    is called <firstterm>electric scrolling</>.
   </para>
   <para>
    Clicking the text area with the right mouse button will
    display the <firstterm>context menu</>, which contains frequently-used
    editing commands.
   </para>
   <tip>
    <para>
     Many characteristics of the text area can be changed in the
     <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
     see <xref linkend=global-opts>.
    </para>
   </tip>
  </sect2>
  <sect2 id=status><title>The Status Area</>
   <indexterm><primary>status bar</></indexterm>
   <indexterm><primary>line number display</></indexterm>
   <para>
    The status area is at the bottom left of the editor window. It
    displays information in the following format:
   </para>
   <screen>col 42 line 7/10 70%</screen>
   <para>
    The first number is the <firstterm>column position</>, or how
    far the caret is from the start of the line. The second pair of
    numbers is the current line, and the total number of lines in
    the buffer. The third number is the ratio of the current line
    to the total number of lines; ie, where the caret is positioned,
    relative to the size of the buffer.
   </para>
  </sect2>
 </sect1>
 <sect1 id=activity-log><title>The Activity Log</>
  <indexterm><primary>Utilities menu</></indexterm>
  <indexterm><primary>Show Activity Log command</></indexterm>
  <indexterm><primary>Save Activity Log command</></indexterm>
  <indexterm><primary>Clear Activity Log command</></indexterm>
  <para>
   Before continuing any further, it is important to know about the
   so-called <quote>activity log</>.
   jEdit writes the following information to the activity log:
  </para>
  <itemizedlist>
   <listitem><para>All error messages and runtime exceptions
   </para></listitem>
   <listitem><para>Information about your Java implementation (version,
   operating system, architecture, etc)</para></listitem>
   <listitem><para>Information about loaded plugins</para></listitem>
   <listitem><para>Messages when files are opened and closed. This
   can be useful in determining what caused an exception</para></listitem>
   <listitem><para>The directory list search logs all file names that
   will be searched</para></listitem>
   <listitem><para>Some plugins may log additional information as
   well</para></listitem>
  </itemizedlist>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Show Activity Log</> displays a
   window showing the current activity log. Text can be copied from
   the log by selecting it and pressing <keycombo><keycap>Control</>
   <keycap>C</></keycombo>.
  </para>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Save Activity Log</> displays a
   file chooser dialog box, allowing you to select a file to save the
   log to.
  </para>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Clear Activity Log</> clears the
   activity log of all information. This is useful when you are debugging
   a problem and want to start over.
  </para>
  <figure><title>The activity log</>
   <graphic fileref=window-log scale=75></>
  </figure>
 </sect1>
 <sect1 id=opening><title>Opening Files</>
  <indexterm><primary>buffer</></indexterm>
  <indexterm><primary>Buffers menu</></indexterm>
  <indexterm><primary>view</></indexterm>
  <indexterm><primary sortas="modified">(modified)</>
  <secondary>in the title bar</></indexterm>
  <indexterm><primary sortas="readonly">(read only)</>
  <secondary>in the title bar</></indexterm>
  <indexterm><primary>command line switches</>
  <secondary>-readonly</></indexterm>
  <indexterm><primary>markers</></indexterm>
  <indexterm><primary>command line</></indexterm>
  <indexterm><primary>saving</></indexterm>
  <para>
   Before a file can be edited, it must first be <firstterm>opened</>.
   When a file is opened, its contents are read into memory and placed in a
   new <firstterm>buffer</>.
   In this manual, a <firstterm>file</> is the file itself, on disk;
   a <firstterm>buffer</> is an open file as it exists in memory,
   with any unsaved changes, etc.
  </para>
  <para>
   All open buffers are listed in the <guimenu>Buffers</> menu; selecting
   one will display that buffer in the current view. The tabs that run
   along the top of the text area can also be used to switch between
   buffers. If you don't like the tabs, they can be disabled in
   <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>; see
   <xref linkend=global-opts> for details.
  </para>
  <para>
   The title bar of views, as well as the entries in the
   <guimenu>Buffers</> menu display various strings depending on the
   status of the buffer. If <quote>(modified)</> is displayed, the
   buffer has unsaved changes that have not yet been written to disk
   (or <firstterm>saved</>). If <quote>(new)</> is displayed, the
   buffer is new; it doesn't exist on disk yet. If <quote>(read only)</> is
   displayed,
   no changes can be made to that buffer. Markers can
   be set in read only files but they will not be saved.
  </para>
  <para>
   Files that you do not have write access to are automatically opened
   read only. Files can also be forced to open read only from the command line
   by specifying the <userinput>-readonly</> option.
  </para>
  <para>
   To make a read only buffer read-write, save it.
   If the save was successful, the read only flag will be cleared (the
   rationale behind this is that if the save was successful, you have
   write access to the file, hence you can make changes).
  </para>
  <para>
   If you edit non-ASCII files, you can select the file
   encoding used by jEdit in
   the 
     <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
     see <xref linkend=global-opts>.
  </para>
  <sect2 id=opencli><title>Opening Files From the Command Line</>
   <para>
    <indexterm><primary>moving the caret</><secondary>
    to a line number</></indexterm>
    <indexterm><primary>command line switches</><secondary>
    --</></indexterm>
    <indexterm><primary>moving the caret</><secondary>
    to a marker</></indexterm>
    <indexterm><primary>markers</></indexterm>
    Any file names passed on the command line are opened by jEdit.
    It is possible to have the caret positioned on a specific line
    after the buffer is opened. For example, to open <filename>paper.tex</>
    and go to line number 247, you would invoke:
   </para>
   <screen><prompt>$</> <userinput>jedit paper.tex#+247</></screen>
   <para>
    It is also possible to move the caret to a specific marker.
    For example, to open <filename>Kernel.java</> and go to
    the marker named <filename>getCommandStack</>, you would invoke:
   </para>
   <screen><prompt>$</> <userinput>jedit Kernel.java#getCommandStack</></screen>
   <para>
    If your file name includes a dash (<quote>-</>), you will need
    to specify the <userinput>--</> (dash-dash) command line parameter before
    it so that it is not treated as a command line switch. For
    example:
   </para>
   <screen><prompt>$</> <userinput>jedit -- -file-name-starting-with-a-dash</></screen>
  </sect2>
  <sect2><title>Opening Files With the Open File Command</>
   <para>
    <indexterm><primary>Open File command</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    <guimenu>File</>&gt;<guimenuitem>Open File</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>O</></keycombo>)
    will display the file open dialog box. Double clicking (or single
    clicking and then clicking <guibutton>Open</>) on a file will open
    it. Double clicking on a directory will list that directory.
   </para>
   <para>
    The file type popup menu in the dialog box contains a list of file
    types; selecting one will make only files of that type visible in
    the file list. This is handy when navigating directories with lots
    of files of different types. The filters can be changed in the
    <guibutton>File Filters</> pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
    dialog box; see <xref linkend=global-opts>.
   </para>
  </sect2>
  <sect2 id=openurl><title>Opening Files With the Open URL Command</>
   <para>
    <indexterm><primary>Open URL command</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    <guimenu>File</>&gt;<guimenuitem>Open URL</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>O</></keycombo>)
    will display the Open URL dialog box. A URL or a file path name
    (relative path names are prefixed with the current buffer's parent
    directory) can be
    entered. Most Java implementations support the <filename>ftp:</>
    and <filename>http:</> URL protocols, so jEdit can open files from
    the Internet directly. However, saving to URLs is not supported.
   </para>
  </sect2>
  <sect2 id=recent><title>Recently Opened Files</>
   <para>
    <indexterm><primary>Recent Files menu</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    The <guisubmenu>Recent Files</> submenu of the <guimenu>File</> menu
    lists the 8 most recently opened files. When a buffer is closed,
    it is added to this list.
   </para>
   <note>
    <para>
     The number of recent files can be changed in the
     <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
     see <xref linkend=global-opts>.
    </para>
   </note>
  </sect2>
  <sect2><title>Current Directory Menu</>
   <para>
    <indexterm><primary>Current Directory menu</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    The <guisubmenu>Current Directory</> submenu of the
    <guimenu>File</> menu lists all files in the frontmost buffer's
    directory. Opening files with this menu can be quicker than using
    the <guimenuitem>Open File</> dialog box.
   </para>
  </sect2>
  <sect2><title>Creating New Files</>
   <indexterm><primary>New File command</></indexterm>
   <indexterm><primary>File menu</></indexterm>
   <para>
    Sometimes, you want to create a blank, new file, instead of editing
    an existing one. There are two ways to do this:
   </para>
   <itemizedlist>
    <listitem><para>
     <guimenu>File</>&gt;<guimenuitem>New File</> (keyboard equivalent:
     <keycombo><keycap>Control</><keycap>N</></keycombo>) will create a new
     <quote>Untitled</> file.
     <indexterm><primary>untitled files</></indexterm>
    </para></listitem>
    <listitem><para>
     Open a non-existent file. If you open a
     non-existent file using any technique described in this
     section, a new file with that name will be created when the buffer
     is first saved.
    </para></listitem>
   </itemizedlist>
  </sect2>
 </sect1>
  <sect1 id=saving><title>Saving Files</>
  <para>
   <indexterm><primary>buffer</></indexterm>
   <indexterm><primary>saving</></indexterm>
   Any changes made to a buffer aren't actually stored to disk immediately
   (but see autosave below); instead, they are stored in the computer's high
   speed memory (RAM) until they are <firstterm>saved</>.
  </para>
  <sect2><title>Autosave and Backups</>
   <para>
    <indexterm><primary>autosave</></indexterm>
    Because computers crash from time to time, not saving
    changes to disk until the user manually does so is not a very good
    idea; most people don't like having to hit <quote>save</> every 2
    minutes, just in case. So jEdit has an autosave feature that should protect
    against possible disasters. Every 15 seconds, all buffers with changes are
    written out to their respective file names, enclosed in hash
    (<quote>#</>) characters. For example, <filename>program.c</> will
    be autosaved to <filename>#program.c#</>. These autosave files do
    not clutter up your disk; they are deleted when the buffer is explicitly
    saved.
    The point of autosaving is so that if jEdit crashes, it should be
    reasonably easy to recover your work - just open the autosave file(s)
    and copy over the autosaved data.
   </para>
   <para>
    <indexterm><primary>backups</></indexterm>
    Another useful safety feature is file backups. When you save a buffer
    for the first time after opening it, its original contents are
    saved to the buffer's file name suffixed with a tilde (<quote>~</>).
    For example, <filename>paper.tex</> is backed up to <filename>paper.tex~</>.
    The point of backups so that if you make extensive changes to a file, and then
    change your mind, you can go back to the previous version.
   </para>
   <tip>
    <para>
     The autosave interval and various backup-related
     settings can be changed in the
     <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
     see <xref linkend=global-opts>.
    </para>
   </tip>
  </sect2>
  <sect2><title>Line Separator Characters</>
   <para>
    <indexterm><primary>MacOS</></indexterm>
    <indexterm><primary>Windows</></indexterm>
    <indexterm><primary>Unix</></indexterm>
    <indexterm><primary>line separator</></indexterm>
    The three major operating systems use different conventions to mark
    line endings in text files.
    The MacOS uses Carriage-Return (\r, ^M) for that purpose. Unix
    uses Newline (\n, ^J). DOS and Windows use Carriage-Return-Newline
    (\r\n, ^M^J). jEdit can handle all three file formats.
   </para>
   <para>
    When a file is loaded, jEdit tries to guess the line separators used
    in that file. When a file is being saved, it uses the line separator it
    found while loading the file. The line separator can be changed manually
    on a per-buffer
    basis in the <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
    see <xref linkend=buffer-opts>.
    The default for new files can be changed in the Editor pane of the
    <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
    see <xref linkend=global-opts>.
   </para>
  </sect2>
  <sect2><title>When Another Application Modifies the File</>
   <indexterm><primary>Reload command</></indexterm>
   <indexterm><primary>File menu</></indexterm>
   <para>
    If you go to save a buffer and jEdit notices that another application
    has changed it on disk, a warning message is displayed. You may
    continue with the save, but the changes by the other application
    will be lost.
   </para>
   <para>
    <guimenu>File</>&gt;<guimenuitem>Reload</> (keyboard equivalent:
    <keycap>F2</>) will reload the file from disk. If the buffer has unsaved
    changes,
    you will be asked for confirmation first.
   </para>
   <para>
    <guimenu>File</>&gt;<guimenuitem>Reload All Buffers</> (keyboard equivalent:
    <keycombo><keycap>Shift</><keycap>F2</></keycombo>) will discard your
    changes in <emphasis>all open buffers</>
    and reload them from disk. This command will ask for confirmation first.
    It is useful after performing a CVS checkin or similar; CVS inserts
    version info in all files it commits, hence they must be re-read from
    disk.
   </para>
   <figure><title>Warning message displayed when another application
   changed the file on disk</>
    <graphic scale=75 fileref=dialog-diskmod></>
   </figure>
  </sect2>
  <sect2><title>Saving Files With the Save Command</>
   <para>
    <indexterm><primary>untitled files</></indexterm>
    <indexterm><primary>Save command</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    <guimenu>File</>&gt;<guimenuitem>Save</> (keyboard equivalent:
    <keycombo><keycap>Control</><keycap>S</></keycombo>)
    will immediately save the buffer to disk, unless the buffer is a
    new file created with the <guimenu>New File</> command, in which
    case the standard save file dialog box will be
    displayed, prompting for a file name and destination directory.
   </para>
  </sect2>
  <sect2><title>Saving Files With the Save As Command</>
   <para>
    <indexterm><primary>Save As command</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    <guimenu>File</>&gt;<guimenuitem>Save As</>
    will prompt for an alternate file name to save the buffer to.
    Note that if you make some changes and <quote>Save As</>, the old
    file will not contain the changes, but the new one will.
    This can be used to create an alternative version of the file and so on.
   </para>
   <para>
    The file type popup menu in the dialog box contains a list of file
    types; selecting one will make only files of that type visible in
    the file list. This is handy when navigating directories with lots
    of files of different types. The filters can be changed in the
    <guibutton>File Filters</> pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
    dialog box; see <xref linkend=global-opts>.
   </para>
  </sect2>
  <sect2><title>Saving All Open Files</>
   <para>
    <indexterm><primary>Save All Buffers command</></indexterm>
    <indexterm><primary>File menu</></indexterm>
    <guimenu>File</>&gt;<guimenuitem>Save All Buffers</>
    (keyboard equivalent:
    <keycap>F3</>) will save all buffers;
    a confirmation dialog box is issued first.
   </para>
  </sect2>
 </sect1>
 <sect1 id=printing-sending><title>Printing and Sending Files</>
  <para>
   <indexterm><primary>Print command</></indexterm>
   <indexterm><primary>File menu</></indexterm>
   <indexterm><primary>Send command</></indexterm>
   <indexterm><primary>selection</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Print</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>P</></keycombo>)
   will print the current buffer. The printed output will have syntax
   highlighting, and a header with the file name at the top of each page.
   <indexterm><primary>syntax highlighting</></indexterm>
  </para>
  <para>
   <guimenu>File</>&gt;<guimenuitem>Send</> will display the send file
   dialog box. <quote>SMTP Server</> should be set to your outgoing
   mail server. <quote>From</> and <quote>To</> are self-explanatory.
   <quote>Subject</> is set to the file name by default; this should
   be changed to something a little more descriptive. If
   <guibutton>Send selected text only</> is selected, only the selected
   text is sent; this is useful for e-mailing code snippets.
  </para>
  <figure><title>The Send dialog box</>
   <graphic scale=75 fileref=dialog-send></>
  </figure>
 </sect1>
 <sect1 id=closing-exiting><title>Closing Files and Exiting jEdit</>
  <para>
   <indexterm><primary>Close File command</></indexterm>
   <indexterm><primary>File menu</></indexterm>
   <indexterm><primary>Exit command</></indexterm>
   <indexterm><primary>saving</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Close File</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>W</></keycombo>)
   will close the current buffer. If it has unsaved changes, jEdit
   will ask if they should be saved first. The
   <guibutton>No</> option discards the unsaved changes with no further
   ado. If you decide you didn't want to close the buffer after all,
   <guibutton>Cancel</> cancels the close operation and
   returns to the editor.
  </para>
  <figure><title>The message displayed if a file has unsaved changes</>
   <graphic scale=75 fileref=dialog-unsaved></>
  </figure>
  <para>
   <indexterm><primary>Close All Buffers command</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Close All Buffers</>
   (keyboard equivalent: <keycap>F4</>)
   will close all currently open buffers. If any buffers have unsaved
   changes, a dialog box will be displayed, listing them all. To discard
   changes to a buffer, select it from the list and click <guibutton>Discard
   Selected</>. To save changes, click <guibutton>Save Selected</>.
   Multiple buffers to operate on can be selected by clicking on them
   while holding down <keycap>Control</>.
  </para>
  <figure><title>The dialog box displayed by Close All Buffers if
  there are unsaved changes</title>
   <graphic scale=75 fileref=dialog-unsaved-list></>
  </figure>
  <para>
   <guimenu>File</>&gt;<guimenuitem>Exit</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>Q</></keycombo>) will completely
   exit jEdit, asking if any unsaved buffers should be saved first.
  </para>
 </sect1>
</chapter>

<chapter id=basic-text-edit><title>Basic Text Editing</>
 <para>
  <indexterm><primary>MacOS</></indexterm>
  <indexterm><primary>Windows</></indexterm>
  <indexterm><primary>Unix</></indexterm>
  <indexterm><primary>Emacs text editor</></indexterm>
  <indexterm><primary>VIM text editor</></indexterm>
  jEdit works in a similar fashion to most MacOS or Windows text
  editors; if you have used one before, quickly skim this section to pick up
  the few jEdit-specific features. If you are more familiar with a
  Unix editor such as Emacs or VIM, read
  this section more carefully; Several things in jEdit are done differently
  from those text editors.
 </para>
 <sect1 id=caret><title>The Caret</>
  <indexterm><primary>moving the caret</><secondary>by characters</></>
  <indexterm><primary>moving the caret</><secondary>by lines</></>
  <indexterm><primary>moving the caret</><secondary>to the start of a line</></>
  <indexterm><primary>moving the caret</><secondary>to the end of a line</></>
  <indexterm><primary>moving the caret</><secondary>to the start of the viewscreen</></>
  <indexterm><primary>moving the caret</><secondary>to the end of the viewscreen</></>
  <indexterm><primary>moving the caret</><secondary>to the start of the buffer</></>
  <indexterm><primary>moving the caret</><secondary>to the end of the buffer</></>
  <indexterm><primary>moving the caret</><secondary>by screenfuls</></>
  <para>
   The <firstterm>caret</> is the location where text editing takes place.
   To make changes to a buffer, the caret must first
   be moved to the location
   where the changes are to take place.
  </para>
  <para>
   The most direct way to move the caret is to click the
   mouse where you want it to be moved.
  </para>
  <para>
   The <keycap>Left</>, <keycap>Right</>, <keycap>Up</> and <keycap>Down</> keys
   move the caret in the respective direction.
  </para>
  <para>
   <keycap>Home</> and <keycap>End</> behave differently depending on
   how many times they are pressed, however if you wish them to behave like
   in other text editors (go to the start and end of the current line only),
   you can specify so in the
   <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog
   box; see <xref linkend=global-opts> for details.
  </para>
  <para>
   The <keycap>Home</> key first moves the caret to the start of the
   current line, then to the top of the viewscreen, and then to the
   beginning of the buffer.
  </para>
  <para>
   The <keycap>End</> key first moves the caret to the end of the
   current line, then to the bottom of the viewscreen, and then to the
   end of the buffer.
  </para>
  <para>
   The caret can also be moved directly to the beginning or end of the
   buffer by pressing <keycap>Control</> in addition to
   <keycap>Home</> or <keycap>End</>.
  </para>
  <para>
   The <keycap>PageUp</> and <keycap>PageDown</> keys move the caret up
   and down one viewscreen, respectively.
  </para>
 </sect1>
 <sect1 id=selection><title>Selecting Text</>
  <indexterm><primary>selection</></>
  <para>
   jEdit has various commands for manipulating arbitriary ranges of text.
   To specify a range of text for further manipulation, it must be
   <firstterm>selected</>. When a range of text is selected, it is drawn
   with a purple highlight (the color can be changed if you don't like it).
   Only one selection can exist at any one time.
  </para>
  <indexterm><primary>selecting text</><secondary>by dragging the mouse</></>
  <para>
   The simplest way to make a selection is to drag the mouse from the start
   of the selection to the end. All text between the two locations will
   be marked. Also, <keycap>Shift</>-clicking in a location in the buffer
   will create a selection from the caret position to where you clicked.
  </para>
  <indexterm><primary>selecting text</><secondary>by using the Shift modifier</></>
  <indexterm><primary>selecting text</><secondary>a line at a time</></>
  <para>
   Holding down <keycap>Shift</> in addition to a caret movement key
   (<keycap>Left</>, <keycap>Up</>, <keycap>Home</>, etc) will extend the
   selection in the specified direction, instead of moving the caret.
   If no selection is active, one will be created.
  </para>
  <indexterm><primary>selecting text</><secondary>the entire buffer</></>
  <para>
   <guimenu>Edit</>&gt;<guimenuitem>Select All</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>A</></keycombo>)
   selects the entire buffer.
  </para>
  <indexterm><primary>selecting text</><secondary>deactivating the selection</></>
  <para>
   <guimenu>Edit</>&gt;<guimenuitem>Select None</> (keyboard equivalent:
   <keycap>Escape</>) deactivates the selection, if there is one.
  </para>
  <figure><title>A selection</>
   <graphic scale=75 fileref=window-editor-select></>
  </figure>
 </sect1>
 <sect1 id=entering-text><title>Entering and Deleting Text</>
  <indexterm><primary>overstrike mode</></indexterm>
  <indexterm><primary>Insert key</></indexterm>
  <para>
   Unless overstrike mode is on (see below) any text typed at the
   keyboard is inserted into the buffer, shifting any text after the
   caret forward. When you are inserting text, keep in mind that
   the <keycap>Tab</>
   and <keycap>Enter</> keys might not behave entirely like you
   expect because various indentation features are enabled;
   see <xref linkend=indent>.
  </para>
  <para>
   Another way to entering text is with the overstrike mode. Pressing
   <keycap>Insert</> will change the caret into the overstrike caret.
   Now, entered text will not be <emphasis>inserted</>, but it will
   <emphasis>replace</> the existing text, character by character.
  </para>
  <indexterm><primary>selection</></indexterm>
  <para>
   Regardless if overstrike mode is on, entering text while a selection
   is active will replace the selection with the newly entered text.
  </para>
  <para>
   <indexterm><primary>deleting</><secondary>characters</></indexterm>
   <indexterm><primary>Backspace key</></indexterm>
   <indexterm><primary>Delete key</></indexterm>
   The <keycap>Backspace</> key deletes the character <firstterm>before</>
   the caret, and <keycap>Delete</> deletes the character <firstterm>in front of</>
   the caret.
  </para>
  <para>
   <indexterm><primary>deleting</><secondary>selected text</></indexterm>
   <indexterm><primary>selection</></indexterm>
   If a selection is active,
   <keycap>Backspace</> and <keycap>Delete</> delete the selected text.
  </para>
 </sect1>
 <sect1 id=undo-redo><title>Undo and Redo</>
  <para>
   Everybody makes mistakes. Especially when editing text. That's
   when jEdit's undo feature is useful.
  </para>
  <para>
   <indexterm><primary>Undo command</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Undo</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>Z</></keycombo>) will reverse the
   most recently performed action. For example, if some text was deleted, this
   will bring it back again.
  </para>
  <para>
   <indexterm><primary>Redo command</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Redo</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>R</></keycombo>) will redo the
   most recently undone action. For example, if some text was deleted,
   invoking <guimenuitem>Undo</> will make the text come back again.
   Invoking <guimenuitem>Redo</> after it was undone will once again
   delete that text.
  </para>
  <para>
   jEdit stores the last 100 editing actions. An editing action can be
   an insertion, a deletion, or something more complicated, such as a
   <guimenuitem>Replace All</> operation.
  </para>
 </sect1>
 <sect1 id=clipboard><title>The Clipboard</>
  <para>
   <indexterm><primary>clipboard</></indexterm>
   The clipboard is a storage area where text and other data can be
   temporarily stored. It is system-wide, and hence can be used to transfer
   data between applications.
  </para>
  <para>
   <indexterm><primary>Unix</></indexterm>
   <indexterm><primary>X Window System</><secondary>cut buffer</>
   </indexterm>
   On Unix systems with the X Window System, there are two clipboards;
   one is used by many applications to store the currently selected
   text, and the other is used with the Cut, Copy and Paste commands.
   jEdit only uses the latter; in fact, it is the only clipboard Java
   allows access to.
  </para>
  <indexterm><primary>selection</></indexterm>
  <para>
   <indexterm><primary>Copy command</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <guimenu>Edit</>&gt;<guimenuitem>Copy</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>C</></keycombo>)
   copies the selected text into the clipboard.
  </para>
  <para>
   <indexterm><primary>Cut command</></indexterm>
   <guimenu>Edit</>&gt;<guimenuitem>Cut</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>X</></keycombo>)
   copies the selected text into the clipboard and deletes it from the
   document.
  </para>
  <para>
   <indexterm><primary>Paste command</></indexterm>
   <guimenu>File</>&gt;<guimenuitem>Paste</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>V</></keycombo>)
   will insert the most recently copied or cut text at the caret position
   (replacing the selection if there is one).
  </para>
  <para>
   <indexterm><primary>Paste Previous command</></indexterm>
   <guimenu>Edit</>&gt;<guimenuitem>Paste Previous</> (keyboard equivalent:
   <keycap>F5</>) will display a list of previously pasted strings, most
   recent first.
   The last 25 are listed. Selecting one will insert it at the caret
   position.
  </para>
  <tip>
   <para>
    The number of pasted strings to remember can be changed in the
    <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
    see <xref linkend=global-opts>.
   </para>
  </tip>
  <figure><title>The Paste Previous dialog box</>
   <graphic scale=75 fileref=dialog-pasteprev></>
  </figure>
 </sect1>
</chapter>

<chapter id=advanced-text-edit><title>Advanced Text Editing</>
 <para>
  jEdit goes far beyond the basics when it comes to text editing; this
  chapter covers some more advanced features.
 </para>
 <sect1 id=words><title>Working With Words</>
  <indexterm><primary>moving the caret</><secondary>by words</></>
  <para>
   jEdit has a variety of commands for working with words. In jEdit,
   words are runs of text separated by non-alphanumeric characters.
   For [a totally idiotic] example, <quote>hello, world</> is considered
   two
   words, <quote>hello</> and <quote>world</> obviously.
  </para>
  <indexterm><primary>selecting text</><secondary>a word at a time</></>
  <indexterm><primary>Edit menu</></>
  <indexterm><primary>Lines menu</></>
  <indexterm><primary>Select Word command</></>
  <para>
   A word can be selected by double-clicking with the mouse. Another
   way to select a word is with the
   <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Select
   Word</> command. The latter is primarily of use in macros, where mouse clicks
   cannot be recorded (but menu item selections can).
  </para>
  <para>
   <keycombo><keycap>Control</><keycap>Left</></keycombo> moves the
   caret to the previous word.
   <keycombo><keycap>Control</><keycap>Right</></keycombo> moves the
   caret to the next word. Holding down shift in addition to one of
   these keys will extend the selection, instead of moving the caret.
  </para>
  <para>
   <indexterm><primary>deleting</><secondary>words</></indexterm>
   Pressing <keycap>Control</> in addition to
   <keycap>Backspace</> or <keycap>Delete</> deletes the word
   <firstterm>before</> and <firstterm>in front of</>
   the caret, respectively.
  </para>
 </sect1>
 <sect1 id=lines><title>Working With Lines</>
  <indexterm><primary>Edit menu</></>
  <indexterm><primary>Go to Line command</></>
  <para>
   Finally, <guimenu>Edit</>&gt;<guimenuitem>Go to Line</> (keyboard
   equivalent: <keycombo><keycap>Control</><keycap>L</></keycombo>) moves the caret
   to the beginning of a line you specify.
  </para>
  <indexterm><primary>Select Line Range command</></>
  <indexterm><primary>selecting text</><secondary>a range of lines</></>
  <para>
   <guimenu>Edit</>&gt;<guimenuitem>Select Line Range</> (keyboard
   equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>L</></keycombo>) prompts for a start line and
   end line, and selects all text between these lines, inclusive.
  </para>
  <indexterm><primary>selecting text</><secondary>a line at a time</></>
  <indexterm><primary>Lines menu</></>
  <indexterm><primary>Select Line command</></>
  <para>
   An entire line can be selected by triple-clicking with the mouse. Another
   way to select a line is with the
   <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Select
   Line</> command. The latter is primarily of use in macros, where mouse clicks
   cannot be recorded (but menu item selections can).
  </para>
  <para>
   <indexterm><primary>scrolling</></indexterm>
   <indexterm><primary>Scroll to Line command</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Scroll
   to Current Line</> (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>J</></keycombo>) centers
   the current line on the screen.
  </para>
  <para>
   <indexterm><primary>Join Lines command</></indexterm>
   <indexterm><primary>joining lines</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Join
   Lines</> (keyboard equivalent: <keycombo><keycap>Control</><keycap>J</></keycombo>)
   removes any whitespace from the start of the next line and joins the
   current and next lines. This will beep if the caret is on the last
   line of the buffer. For example, if the caret is on the first line
   of the following example Java code:
  </para>
  <screen>new Widget(Foo
       .createDefaultFoo());</screen>
  <para>
   <guimenuitem>Join Lines</> will change it to:
  </para>
  <screen>new Widget(Foo.createDefaultFoo());</screen>
  <para>
   <indexterm><primary>deleting</><secondary>lines</></indexterm>
   <indexterm><primary>Delete Line command</></indexterm>
   <indexterm><primary>Lines menu</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Delete Line</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>D</></keycombo>)
   will
   delete the line that the caret is positioned on.
  </para>
  <para>
   <indexterm><primary>deleting</><secondary>parts of lines</></indexterm>
   <indexterm><primary>Delete To Start Of Line command</></indexterm>
   <indexterm><primary>Lines menu</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Delete to
   Start Of Line</>
   (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>Shift</><keycap>Backspace</></keycombo>)
   will
   delete all text from the caret position to the start of the line.
  </para>
  <para>
   <indexterm><primary>Delete To End Of Line command</></indexterm>
   <indexterm><primary>Lines menu</></indexterm>
   <indexterm><primary>Edit menu</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guimenuitem>Delete to
   End Of Line</>
   (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>Shift</><keycap>Delete</></keycombo>)
   will
   delete all text from the caret position to the end of the line.
  </para>
 </sect1>
 <sect1 id=paragraphs><title>Working With Paragraphs</>
  <para>
   As far as jEdit is concerned, a <quote>paragraph</> is a block of
   text enclosed with double-newlines. This is also how <application>TeX</>
   defines a paragraph. Note that jEdit doesn't parse HTML files for
   <quote>&lt;P&gt;</> tags, nor does it support paragraphs delimited only
   by a leading indent.
  </para>
  <indexterm><primary>Edit menu</></indexterm>
   <indexterm><primary>Paragraphs menu</></indexterm>
   <indexterm><primary>Selection menu</></indexterm>
   <indexterm><primary>moving the caret</><secondary>by paragraphs</></>
  <indexterm><primary>selecting text</><secondary>paragraphs</></>
  <para>
   <keycombo><keycap>Control</><keycap>Up</></keycombo> moves the
   caret to the previous paragraph.
   <keycombo><keycap>Control</><keycap>Down</></keycombo> moves the
   caret to the next paragraph. Holding down shift in addition to one of
   these keys will extend the selection, instead of moving the caret.
  </para>
  <para>
   <indexterm><primary>Select Paragraph command</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Select
   Paragraph</> will
   select the paragraph containing the caret
   The latter is primarily of use in macros, where mouse clicks
   cannot be recorded (but menu item selections can).
  </para>
  <para>
   <indexterm><primary>deleting</><secondary>paragraphs</></indexterm>
   <indexterm><primary>Delete Paragraph command</></indexterm>
   <guimenu>Edit</>&gt;<guisubmenu>Paragraphs</>&gt;<guimenuitem>Delete
   Paragraph</> (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</>
   </keycombo> <keycombo><keycap>Control</><keycap>D</></keycombo>) will
   delete the paragraph containing the caret.
  </para>
 </sect1>
 <sect1 id=views><title>Working With Views</>
  <para>
   <indexterm><primary>view</></indexterm>
   <indexterm><primary>editor window</></indexterm>
   By default, jEdit only creates one editor window, or <firstterm>view</>.
   However, it is possible to have any number of views open at once, with
   each buffer being edited in one or more views. Views can also be split
   into multiple panes, for side-by-side viewing of two locations in a
   single
   buffer.
  </para>
  <para>
   <indexterm><primary>New View command</></indexterm>
   <indexterm><primary>Utilities menu</></indexterm>
   <guimenu>Utilities</>&gt;<guimenuitem>New View</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>N</></keycombo>) will create a new
   view. It will display the same buffer as the current view.
   A different buffer can also be selected from
   the <guimenu>Buffers</> menu.
  </para>
  <para>
   <indexterm><primary>Close View command</></indexterm>
   <guimenu>Utilities</>&gt;<guimenuitem>Close View</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>N</></keycombo>) will close the
   current view. jEdit will then exit if no more views remain.
  </para>
  <para>
   <indexterm><primary>Split Vertically command</></indexterm>
   <guimenu>Utilities</>&gt;<guimenuitem>Split Vertically</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycap>2</>) will vertically split the current view.
  </para>
  <para>
   <indexterm><primary>Split Horizonally command</></indexterm>
   <guimenu>Utilities</>&gt;<guimenuitem>Split Horizonally</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycap>3</>) will horizontally split the current view.
  </para>
  <para>
   <indexterm><primary>Unsplit command</></indexterm>
   <guimenu>Utilities</>&gt;<guimenuitem>Unsplit</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycap>1</>) will remove all splits from the current view.
  </para>
  <note>
   <para>
    A split view can still only display one buffer at a time. If you need
    to simultaneously view two buffers at once, you must create a new
    view.
   </para>
  </note>
  <figure><title>A view split into two panes</>
   <graphic scale=75 fileref=window-editor-split></>
  </figure>
 </sect1>
 <sect1 id=server><title>The Edit Server</>
  <para>
   Because opening a new copy of jEdit every time it was invoked from the command
   line, or had a file dropped onto its icon, would waste memory (and consume time),
   jEdit has a feature known as the <firstterm>edit server</>. When jEdit is
   started, it attempts to connect to another running jEdit instance. If the connection
   was
   successful, it transfers control to that running instance, passing it any
   necessary file names. Only if no other running instance can be found does
   jEdit start up for real.
  </para>
  <para>
   The edit server is implemented using sockets. When a server is started, it
   picks a random port number and authorization key and writes it to a
   <firstterm>port file</> (usually in a well-known location). Client instances
   of jEdit then read the port file and connect to the specified port, passing
   it the authorization key.
  </para>
  <para>
   The authorization key is required to prevent malicious remote attackers from
   opening files
   on your compiler.
  </para>
  <para>
   <indexterm><primary>command line switches</><secondary>-noserver</></indexterm>
   <indexterm><primary>command line</></indexterm>
   <indexterm><primary>command line switches</><secondary>-server</></indexterm>
   The <command>-noserver</> command line switch disables the server features entirely;
   no connection will be attempted, and no sever will be started. The
   <command>-server</> command line switch can be used to change the file
   where port information is stored. This can be used when
   you want to run more than one copy of jEdit at once. For example:
  </para>
  <screen><prompt>$</> <userinput>jedit -server=my-server-2</></screen>
  <para>
   The same <command>-server</> parameter must be passed to <emphasis>both</>
   the server and client.
  </para>
  <para>
   <indexterm><primary>command line switches</><secondary>-nosettings</></indexterm>
   <indexterm><primary>command line switches</><secondary>-settings</></indexterm>
   <indexterm><primary>command line switches</><secondary>-nosplash</></indexterm>
   <indexterm><primary>command line</></indexterm>
   All jEdit command line parameters except those that affect initial
   startup (<command>-nosettings</>, <command>-settings</>
   and <command>-nosplash</>) are handled appropriately by the server.
  </para>
  <para>
   <indexterm><primary>command line switches</><secondary>-reuseview</></indexterm>
   In some circumstances, it might be desirable for the client instance
   to open the files in an existing view, rather than creating a new one.
   The <command>-reuseview</> switch can be used for that purpose.
  </para>
 </sect1>
 <sect1 id=sessions><title>Saving and Loading Sessions</>
  <para>
   <indexterm><primary>sessions</></>
   <indexterm><primary>command line switches</><secondary>-nosession</></indexterm>
   <indexterm><primary>command line switches</><secondary>-session</></indexterm>
   When working on a project, it can sometimes be convenient to save
   the list of open files, and re-open those files at a later time.
   jEdit's saved sessions can do this.
  </para>
  <para>
   jEdit sessions are plain text files with the extension
   <filename>.session</>, stored in the
   <filename>$HOME/.jedit/sessions</> directory. The session named
   <filename>default.session</> is loaded on startup, and the list of
   open files is recorded into it when jEdit exits. The end result is
   that open files are retained across editing sessions. This
   <quote>default</> session can be disabled in the
   <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
   dialog box; see <xref linkend=global-opts>.
  </para>
  <para>
   A session to load can be specified on the command line using the
   <command>-session</> switch. For example, the following will open
   all files in the <filename>website</> session (the <filename>.session</>
   suffix, if left off, is appended to session names automatically):
   <screen><prompt>$</> <userinput>jedit -session=website</></screen>
   The <command>-nosession</> command line switch will instruct jEdit
   not to load a session, and instead open an <filename>Untitled</>
   file.
  </para>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Load Session</> loads
   a session while jEdit is running from a file specified in a file
   selection dialog box.
  </para>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Save Session</> saves the list of
   all open files to a session specified in a file selection dialog box.
  </para>
 </sect1>
 <sect1 id=markers><title>Markers</>
  <para>
   <indexterm><primary>Unix</></indexterm>
   <indexterm><primary>.filename.marks file</></indexterm>
   <indexterm><primary>markers</></indexterm>
   A marker is a named location in a buffer. There can be any number
   of markers defined. Markers are preserved across editing sessions;
   markers for file <filename>filename</> are saved to
   <filename>.filename.marks</>. The dot prefix is necessary to make
   the file hidden on Unix systems.
  </para>
  <para>
   Markers are kept sorted according to their position in the
   buffer. Combined with the fact that they are saved across editing
   sessions, this makes them very useful for marking chapters in an online book,
   etc.
  </para>
  <para>
   <indexterm><primary>Set Marker command</></indexterm>
   <indexterm><primary>Search menu</></indexterm>
   <indexterm><primary>selection</></indexterm>
   <guimenu>Search</>&gt;<guimenuitem>Set Marker</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>M</></keycombo>) will prompt for
   a marker name (the default being the selected text) and set a
   marker at the caret position.
  </para>
  <para>
   <indexterm><primary>moving the caret</><secondary>to a
   marker</></indexterm>
   <indexterm><primary>Go to Marker menu</></indexterm>
   The <guimenu>Search</>&gt;<guisubmenu>Go to Marker</> menu lists all
   markers defined in the current buffer. Selecting a marker will move the
   caret to that marker.
  </para>
  <para>
   <indexterm><primary>Clear Marker menu</></indexterm>
   The <guimenu>Search</>&gt;<guisubmenu>Clear Marker</> menu lists all
   markers defined in the current buffer. Selecting a marker will delete
   it from the buffer.
  </para>
 </sect1>
 <sect1 id=repeats><title>Repeating Commands</>
  <indexterm><primary>Edit menu</></indexterm>
  <indexterm><primary>Go to Line command</></indexterm>
  <para>
   Quite often while editing text, you need to insert a character or perform
   a command several times in a row. jEdit's repeat feature facilitates this.
   Keyboard commands, menu item selections and tool bar clicks can be repeated.
  </para>
  <para>
   Pressing <keycombo><keycap>Control</><keycap>Enter</></keycombo> allows
   you to enter a number using the digit keys (0-9).
   The first non-digit character will be
   repeated that number of times. For example,
   <quote><keycombo><keycap>Control</><keycap>Enter</></keycombo>
   <keycap>1</> <keycap>4</>
   <keycombo><keycap>Control</><keycap>D</></keycombo>
   <keycombo><keycap>Control</><keycap>D</></keycombo></quote> will delete
   14 lines, and <quote><keycombo><keycap>Control</><keycap>Enter</></keycombo>
   <keycap>8</> <keycap>0</>
   <keycap>#</></quote>
   will insert the <quote>#</> character 80 times.
  </para>
  <para>
   Most commands behave as expected when repeated, with one exception:
   if given a repeat count, the <guimenu>Edit</>&gt;<guimenuitem>Go to Line</>
   command will move the caret to that line. If no repeat count is given, it
   will display the go to line dialog box.
  </para>
 </sect1>
 <sect1 id=rect-select><title>Rectangular Selection</>
  <para>
   <indexterm><primary>selecting</><secondary>columns of text</></indexterm>
   Not only is it possible to select continuous runs of text, but
   columns of text can also be selected.
  </para>
  <para>
   There are three ways to create a rectangular selection. The simplest
   way is to drag the mouse from one corner of the rectangle to another
   while holding down the <keycap>Control</> key.
  </para>
  <para>
   Clicking the mouse button while holding down <keycombo><keycap>Shift</>
   <keycap>Control</></keycombo> will create a rectangle from the caret
   position to where the mouse was clicked.
  </para>
  <indexterm><primary>Rectangular Selection command</></indexterm>
  <indexterm><primary>Edit menu</></indexterm>
  <indexterm><primary>Selection menu</></indexterm>
  <para>
   <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Rectangular
   Selection</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>\</></keycombo>)
   will toggle the current selection between continuous and rectangular mode.
  </para>
  <para>
   It is possible to select a rectangle with zero width, but non-zero height.
   For example, this can be used to insert a column between two existing
   columns. Such selections are shown as a thin vertical line.
  </para>
  <para>
   Deleting, replacing, copying, pasting, and so on works as expected on
   rectangles. Some plugins might not be rectangle-aware, and
   cause problems. All commands built in to jEdit should work, however.
  </para>
  <note>
   <para>
    Because rectangles rely on character offsets, rather than absolute
    screen positions, they may behave strangely when proportional-width
    fonts, or tabs, are used. Try to use monospaced fonts and soft tabs
    when editing columnar files.
   </para>
  </note>
  <figure><title>A rectangular selection</>
   <graphic scale=75 fileref=window-editor-rect-sel></>
  </figure>
 </sect1>
 <sect1 id=registers><title>Registers</>
  <para>
   A <firstterm>register</> is place where you can save a string or caret
   position for later use.
   Each register has a single-character name (hence the number of registers
   is limited by how many distinct keys can be typed on your keyboard),
   and can contain a string or a caret position.
  </para>
  <para>
   All register-related commands except for <guimenuitem>View Registers</>,
   once invoked, grab the next character entered at the keyboard and use
   that as the register to operate on. So to copy the selection to register
   <filename>X</>, you can type <keycombo><keycap>Control</><keycap>R</></keycombo>
   <keycombo><keycap>Control</><keycap>C</></keycombo> <keycap>X</>.
  </para>
  <para>
   Registers are global; all buffers share the same set. The contents of
   registers are not saved across editing sessions.
  </para>
  <sect2 id=string-registers><title>String Registers</>
   <indexterm><primary>Registers menu</></indexterm>
   <indexterm><primary>Cut to Register command</></indexterm>
   <indexterm><primary>Copy to Register command</></indexterm>
   <indexterm><primary>Append to Register command</></indexterm>
   <indexterm><primary>Paste from Register command</></indexterm>
   <indexterm><primary>Paste Previous command</></indexterm>
   <indexterm><primary>clipboard</></indexterm>
   <indexterm><primary>selection</></indexterm>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Cut to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>R</></keycombo>
    <keycombo><keycap>Control</><keycap>X</></keycombo>) reads the next
    character entered at the keyboard, and copies the selected text to that
    register, removing it from the buffer.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Copy to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>R</></keycombo>
    <keycombo><keycap>Control</><keycap>C</></keycombo>) reads the next
    character entered at the keyboard, and copies the selected text to that
    register, leaving it in the buffer.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Append to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>R</></keycombo>
    <keycombo><keycap>Control</><keycap>C</></keycombo>) reads the next
    character entered at the keyboard, and appends the selected text to that
    register, leaving it in the buffer. This can be used to merge several
    text strings and insert them into a different buffer in one operation.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Paste from Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>R</></keycombo>
    <keycombo><keycap>Control</><keycap>V</></keycombo>) reads the next
    character entered at the keyboard, and replaces the selection with the
    contents of that register. Every time you paste from a register,
    the pasted text is added to the clipboard history displayed in the
    <guimenu>Edit</>&gt;<guimenuitem>Paste Previous</> dialog box;
    see <xref linkend=clipboard>.
   </para>
   <para>
    The register <filename>$</> is an alias for the clipboard; so copying
    to that register has the same effect as
    <guimenu>Edit</>&gt;<guimenu>Copy</>.
   </para>
  </sect2>
  <sect2 id=pos-registers><title>Caret Registers</>
   <indexterm><primary>Registers menu</></indexterm>
   <indexterm><primary>Save Caret to Register command</></indexterm>
   <indexterm><primary>Go to Register command</></indexterm>
   <indexterm><primary>Select to Register command</></indexterm>
   <indexterm><primary>Swap Caret with Register command</></indexterm>
   <indexterm><primary>selection</></indexterm>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Save Caret to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>T</></keycombo>)
    reads the next character entered at the keyboard, and saves the current
    buffer name and caret position to that register. Because the buffer name
    is saved in caret registers, you can use them to quickly flip between
    multiple buffers.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Go to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>Y</></keycombo>)
    reads the next character entered at the keyboard, switches to the buffer
    name saved in that register (opening it if necessary), and moves the caret
    to the saved position.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Select to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>U</></keycombo>)
    reads the next character entered at the keyboard, and creates a selection
    from the caret position to the offset specified in that register.
    Keep in mind that if the register points to a different buffer,
    the selection may be meaningless.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Swap Caret with Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>K</></keycombo>)
    reads the next character entered at the keyboard, and swaps the caret
    position and current buffer with that entered in the register. If invoked
    repeatedly, it can be used to flip between two buffers and/or caret
    positions.
   </para>
  </sect2>
  <sect2 id=filename-registers><title>File Name Registers</>
   <indexterm><primary>Registers menu</></indexterm>
   <indexterm><primary>Save Filename to Register command</></indexterm>
   <indexterm><primary>Go to Register command</></indexterm>
   <para>
    Registers can also be used to store file names to visit. Internally,
    jEdit makes no distinction between a file name and string register;
    they can be used interchangeably.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Save Filename to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>R</></keycombo>
    <keycombo><keycap>Control</><keycap>F</></keycombo>) reads the next
    character entered at the keyboard, and saves the current buffer's path
    name to that register.
   </para>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>Go to Register</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>T</></keycombo>)
    reads the next character entered at the keyboard, and opens the buffer
    named by the contents of that register. This is the same command
    used to go to a caret register.
   </para>
  </sect2>
  <sect2><title>Viewing Register Contents</>
   <indexterm><primary>Registers menu</></indexterm>
   <indexterm><primary>View Registers command</></indexterm>
   <para>
    <guimenu>Edit</>&gt;<guisubmenu>Registers</>&gt;<guimenuitem>View Registers</>
    (keyboard equivalent: <keycap>F6</>) shows a
    dialog box with a scrollable list of all defined registers.
   </para>
   <para>
    The contents of string registers are displayed as-is. For caret registers,
    the
    file name and stored caret position is displayed.
   </para>
   <para>
    Currently, it is not possible to change or add registers from this
    dialog box; use the register commands instead.
   </para>
   <figure><title>The View Registers dialog box</>
    <graphic scale=75 fileref=dialog-view-registers></>
   </figure>
  </sect2>
 </sect1>
 <sect1 id=abbrevs><title>Abbreviations</>
  <indexterm><primary>Edit menu</></indexterm>
  <indexterm><primary>Expand Abbreviation command</></indexterm>
  <para>
   An abbreviation is a string, that when inserted, expands into some
   other, presumably longer and harder to type string. Abbreviations are
   useful for inserting long but frequently used strings easily. For example,
   you can define an abbreviation <quote>sout</> that expands to
   <quote>System.out.println</> in Java mode.
  </para>
  <para>
   There are two types of abbreviations; global abbrevs and mode-specific
   abbrevs. Global abbrevs can be expanded in any edit mode, and
   mode-specific ones only affect one particular edit mode.
  </para>
  <para>
   There are two ways to expand an abbrev. Firstly,
   <guimenu>Edit</>&gt;<guimenuitem>Expand Abbreviation</> (keyboard
   shortcut: <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>X</></keycombo>) will attempt to
   expand the word before the caret. It will beep if no expansion could
   be found. Secondly, if automatic abbreviation expansion is enabled, entering
   a non-alphanumeric character will automatically try to expand the word
   before the caret. This is a very powerful feature, but it takes some
   getting used to, hence it is disabled by default.
  </para>
  <para>
   If automatic expansion
   is enabled and you want to enter a non-alphanumeric character without
   expanding the current word, prefix the character with
   <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>V</></keycombo>. For example,
   to enter a space without expanding the current word, you would type
   <keycombo><keycap>Control</><keycap>E</></keycombo>
   <keycombo><keycap>Control</><keycap>V</></keycombo> <keycap>Space</>.
  </para>
  <para>
   Abbreviations can be edited in the <guibutton>Abbreviations</> pane
   of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
   see <xref linkend=global-opts>. Abbreviations are preserved across
   editing sessions.
  </para>
  <tip>
   <para>
    Abbreviation expansion behaves in a very quirky manner when used from
    a macro - don't use abbrevs when
    recording macros.
   </para>
  </tip>
 </sect1>
 <sect1 id=macros><title>Macros</>
  <para>
   A <firstterm>macro</> is a prerecorded sequence of events that can be
   played back at any time. Macros can be used to automate complex operations
   and repeat a set of commands many times.
  </para>
  <sect2 id=macro-files><title>Macro Files</>
   <para>
    Each macro is stored as a file in the <filename>macros</> subdirectory
    of the jEdit install directory, or the <filename>.jedit/macros</>
    subdirectory of the user's home directory. The former contains several
    sample macros included with jEdit, and the latter should be used to
    store user-defined macros.
   </para>
   <para>
    Macro files have the
    extension <quote>.macro</> and use a very simple syntax, with
    one command per line. Lines starting with a hash (<quote>#</>) are
    ignored by the macro interpreter and can be used to add commentary
    to macros, etc.
   </para>
   <indexterm><primary>Macros menu</></indexterm>
   <indexterm><primary>Rescan Macros command</></indexterm>
   <para>
    The <guimenu>Macros</> menu lists all known macros, in addition
    to commands for working with them. Creating subdirectories
    in the macros directory works as expected; they
    are displayed as submenus of the <guimenu>Macros</> menu. This can be
    used to organize a large collection of macros.
    The
    <guimenu>Macros</> menu is automatically
    refreshed when you update or create a macro file from within jEdit.
    Because macros are stored as ordinary files, they can be renamed,
    deleted and so on with your operating system's file manager. If you
    make changes to the macros from outside of jEdit, the
    <guimenu>Macros</>&gt;<guimenuitem>Rescan Macros</> command should be used
    to update the macros menu with the changes.
   </para>
   <para>
    Like all other menu item commands, macros can be assigned shortcuts in
    the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
    see <xref linkend=global-opts>.
   </para>
   <indexterm><primary>Play Last Macro command</></indexterm>
   <para>
    To play a macro, select it from the <guimenu>Macros</> menu. The
    most recently recorded or played macro can be invoked with the
    <guimenu>Macros</>&gt;<guimenuitem>Play Last Macro</> command (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>M</></keycombo>
    <keycombo><keycap>Control</><keycap>L</></keycombo>
   </para>
  </sect2>
  <sect2 id=macro-record><title>Recording Macros</>
   <indexterm><primary>Macros menu</></indexterm>
   <indexterm><primary>Record Macro command</></indexterm>
   <para>
    <guimenu>Macros</>&gt;<guimenuitem>Record Macro</> (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>M</></keycombo>
    <keycombo><keycap>Control</><keycap>R</></keycombo>) prompts for
    a macro name, and begins recording to a file with that name
    suffixed with <quote>.macro</>.
   </para>
   <para>
    While a recording is in progress, <quote>Macro recording</> is
    displayed in the status bar, instead of the caret position information.
    Currently, jEdit records key strokes, commands invoked from
    the menu bar, and tool bar clicks.
   </para>
   <para>
    Search and replace operations are recorded to macros.
    when the macro is played back, the actual search and replacement is
    performed, and the dialog boxes are not displayed.
   </para>
   <indexterm><primary>Stop Recording command</></indexterm>
   <para>
    <guimenu>Macros</>&gt;<guimenuitem>Stop Recording</> (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>M</></keycombo>
    <keycombo><keycap>Control</><keycap>S</></keycombo>) stops any
    recording currently in progress. It also switches to the buffer where
    the macro was being recorded, giving you a chance to check over the
    commands
    and make any necessary changes.
    When you are happy with the macro, simply
    save it and it will automatically appear in the <guimenu>Macros</>
    menu. If you wish to discard the macro, close it without
    saving.
   </para>
  </sect2>
  <sect2 id=macro-temp><title>Temporary Macros</>
   <para>
    Sometimes, a complicated action only needs to be repeated a couple of
    times, and it is not worth creating a new macro file. The
    temporary macro feature is useful in those situations.
   </para>
   <indexterm><primary>Macros menu</></indexterm>
   <indexterm><primary>Record Temporary Macro command</></indexterm>
   <para>
    <guimenu>Macros</>&gt;<guimenuitem>Record Temporary Macro</> (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>M</></keycombo>
    <keycombo><keycap>Control</><keycap>M</></keycombo>) works in a
    similar fashion to the <guimenuitem>Record Macro</> command, except that
    it records to a buffer named <filename>__temporary__.macro</>.
   </para>
   <indexterm><primary>Stop Recording command</></indexterm>
   <para>
    <guimenu>Macros</>&gt;<guimenuitem>Stop Recording</> stops recording the
    temporary macro. This is the same command used to stop recording an
    ordinary macro.
    Once recording is complete, the <filename>__temporary__.macro</>
    buffer need not be saved. However, if you do save it, it will become
    an ordinary macro, displayed in the <guimenu>Macros</> menu.
   </para>
   <indexterm><primary>Play Temporary Macro command</></indexterm>
   <para>
    <guimenu>Macros</>&gt;<guimenuitem>Play Temporary Macro</> (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>M</></keycombo>
    <keycombo><keycap>Control</><keycap>P</></keycombo>) plays the
    macro recorded to the <filename>__temporary__.macro</> buffer.
   </para>
  </sect2>
 </sect1>
 <sect1 id=misc-commands><title>Miscellaneous Commands</>
  <para>
   Over time, jEdit has accumulated a number of miscellaneous commands that
   defy categorization, yet are useful in some circumstances. This section
   will describe them.
  </para>
  <sect2><title>Word Count</>
   <para>
    <indexterm><primary>Word Count command</></indexterm>
    <indexterm><primary>Edit menu</></indexterm>
    <guimenu>Edit</>&gt;<guimenuitem>Word Count</>
    displays a dialog box with the number of characters,
    words and lines in the current buffer. A word is a string of text
    delimited by spaces.
   </para>
   <figure><title>The word count dialog box</>
    <graphic scale=75 fileref=dialog-wordcount></>
   </figure>
  </sect2>
  <sect2><title>Word Competion</title>
   <para>
    <indexterm><primary>Complete Word command</></indexterm>
    <guimenu>Edit</>&gt;<guimenuitem>Complete Word</> (keyboard
    equivalent:
    <keycombo><keycap>Control</><keycap>B</></keycombo>) attempts to
    compete the current word by searching the buffer for
    other words beginning with the current word. Invoking it multiple times
    will cycle through all possible completions. This can be used to
    enter previously typed, long identifiers in program source, for example.
   </para>
   <para>
    <indexterm><primary>buffer-local properties</>
    <secondary>noWordSep</></indexterm>
    A word is defined as a string of alphanumeric characters, and
    any non-alphanumeric characters listed in the <quote>noWordSep</>
    buffer-local property. For example, to be able to complete words containing
    hyphens (<quote>-</>), place the following in the first 10 lines of
    the buffer:
   </para>
   <screen>:noWordSep=-:</screen>
  </sect2>
 </sect1>
</chapter>

<chapter id=source-edit><title>Source Code Editing</>
 <para>
  Most often, a text editor is used to edit files with some sort
  of structure, like program source code, or HTML, TeX, and so on.
  jEdit has several features for making this easier, including edit modes,
  bracket matching, various indentation commands, auto indent,
  commands for commenting source, and syntax highlighting.
 </para>
 <sect1 id=modes><title>Edit Modes</>
  <indexterm><primary>syntax highlighting</></indexterm>
  <indexterm><primary>auto indent</></indexterm>
  <indexterm><primary>edit modes</></indexterm>
  <para>
   Because it is impossible to provide optimal editing for all types of
   files at once, jEdit provides various <firstterm>edit modes</>. An edit mode
   is an editor configuration suitable for editing a specific
   type of file. Edit modes can specify syntax highlighting, auto indent,
   and various other settings for editing a file type.
  </para>
  <sect2><title>Automatic Mode Selection</>
   <para>
    <indexterm><primary>file name extensions</></indexterm>
    When a file is opened, jEdit first checks the file name against a list
    of known patterns. For example, files whose names end with <quote>.c</>
    are edited in C mode, and files named <filename>Makefile</> are edited in
    Makefile mode. If a suitable match based on file name cannot be found,
    jEdit checks the first line of the file. For example, files whose first
    line is <quote>#!/bin/sh</> are edited in shell script mode.
   </para>
  </sect2>
  <sect2><title>Manually Setting the Edit Mode</>
   <indexterm><primary>buffer-local properties</>
   <secondary>mode</></indexterm>
   <para>
    If automatic mode selection is not appropriate, the edit mode can
    be specified manually. To set the current buffer's edit mode
    on a one-time basis, select the edit mode in the
    <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
    see <xref linkend=buffer-opts>.
    To have a buffer open with a specific edit mode every time,
    set the <quote>mode</> buffer-local property to the
    name of the desired edit mode by placing
    the following text in one of the first 10 lines of the buffer:
   </para>
   <screen>:mode=<replaceable>edit mode</>:</screen>
   </sect2>
  <sect2><title>Available Edit Modes</>
   <table><title>Table of edit modes</>
    <tgroup cols=2>
     <colspec colnum=1 colwidth=1in>
     <thead>
      <row>
       <entry>Mode name</>
       <entry>Comments</>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>bat</>
       <entry>MS-DOS Batch File edit mode. Automatically selected for
       files with extension <quote>.bat</>.</entry>
      </row>
      <row>
       <entry>c</>
       <entry>C source code edit mode. Automatically selected for
       files with extension <quote>.c</> or <quote>.h</>.</entry>
      </row>
      <row>
       <entry>cc</>
       <entry>C++ source code edit mode. Automatically selected for
       files with a variety of C++ extensions.</entry>
      </row>
      <row>
       <entry>eiffel</>
       <entry>Eiffel source code edit mode. Automatically
       selected for files with extension <quote>.e</>.
       </entry>
      </row>
      <row>
       <entry>html</>
       <entry>HTML source code edit mode. Automatically selected for
       files with extension <quote>.html</>, <quote>.shtml</> or <quote>.htm</>.
       </entry>
      </row>
      <row>
       <entry>idl</>
       <entry>CORBA IDL (Interface Definition Language) edit mode.
       Automatically selected for
       files with extension <quote>.idl</>.</entry>
      </row>
      <row>
       <entry>java</>
       <entry>Java source code edit mode. Automatically selected for
       files with extension <quote>.java</>.</entry>
      </row>
      <row>
       <entry>javascript</>
       <entry>JavaScript source code edit mode. Automatically selected for
       files with extension <quote>.js</>.</entry>
      </row>
      <row>
       <entry>make</>
       <entry>Makefile edit mode. Automatically selected for files named
       <quote>Makefile</> or <quote>GNUmakefile</>.
       </entry>
      </row>
      <row>
       <entry>patch</>
       <entry>Edit mode for Unix diffs and patches. Automatically selected
       for files with extension <quote>.diff</> or <quote>.patch</>.
       </entry>
      </row>
      <row>
       <entry>perl</>
       <entry>Perl edit mode. Automatically selected for files with
       extension <quote>.pl</> or <quote>.pm</>, and whose first line
       contains <quote>#!</> and <quote>perl</>.
       </entry>
      </row>
      <row>
       <entry>php3</>
       <entry>PHP3 edit mode. Automatically selected for files with
       extension <quote>.php3</>, <quote>.php</>,
       <quote>.phtml</> or <quote>.inc</>.
       </entry>
      </row>
      <row>
       <entry>postscript</>
       <entry>PostScript edit mode. Automatically
       selected for files with extension <quote>.ps</>.
       </entry>
      </row>
      <row>
       <entry>props</>
       <entry>Java property file and MS-DOS INI edit mode. Automatically
       selected for files with extension <quote>.props</> or <quote>.ini</>,
       and files named <quote>config.sys</> or <quote>properties</>.
       </entry>
      </row>
      <row>
       <entry>python</>
       <entry>Python script edit mode. Automatically
       selected for files with extension <quote>.py</> or whose first line
       contains <quote>#!</> and <quote>python</>.
       </entry>
      </row>
      <row>
       <entry>shell</>
       <entry>Unix shell script edit mode. Automatically selected for files
       with extension <quote>.sh</> or <quote>.csh</>,
       and files whose first line is
       <quote>#!</> followed by one of the various Unix shell names.
       </entry>
      </row>
      <row>
       <entry>tex</>
       <entry>TeX edit mode. Automatically selected for files with
       extension <quote>.tex</>.
       </entry>
      </row>
      <row>
       <entry>text</>
       <entry>Default edit mode. Does nothing special.</>
      </row>
      <row>
       <entry>tsql</>
       <entry>Transact-SQL edit mode. Automatically selected for files with
       extension <quote>.sql</>.
       </entry>
      </row>
      <row>
       <entry>xml</>
       <entry>XML and SGML source code edit mode. Automatically selected for
       files with extension <quote>dtd</>,
       <quote>rdf</>,
       <quote>rss</>,
       <quote>sgm</>,
       <quote>sgml</>,
       <quote>xml</>,
       <quote>xsd</>
       or <quote>xsl</>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 id=bracket-matching><title>Bracket Matching</>
  <indexterm><primary>bracket matching</></indexterm>
  <indexterm><primary>Locate Bracket command</></indexterm>
  <indexterm><primary>Go to Previous Bracket command</></indexterm>
  <indexterm><primary>Go to Next Bracket command</></indexterm>
  <indexterm><primary>Edit menu</></indexterm>
  <indexterm><primary>selecting</><secondary>a code block</></indexterm>
  <indexterm><primary>Select Code Block command</></indexterm>
  <indexterm><primary>Source Code menu</></indexterm>
  <para>
   Misplaced and unmatched brackets are one of the most common syntax
   errors encountered when writing code. jEdit has several features
   which make brackets easier to deal with.
  </para>
  <para>
   If the caret is in front of a bracket, the matching
   one is highlighted (assuming it is visible on the
   screen). The bracket highlight color can be changed in the
   Colors &amp; Styles pane of the <guimenu>File</>&gt;<guimenuitem>Global
   Options</> dialog box; see <xref linkend=global-opts>.
   Bracket highlighting can be disabled
   in the Editor pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
   dialog box; see <xref linkend=global-opts>.
  </para>
  <para>
   <guimenu>Edit</>&gt;<guisubmenu>Source Code</>&gt;<guimenuitem>Select Code Block</>
   (keyboard equivalent: <keycombo><keycap>Control</><keycap>[</></keycombo>)
   will select the code block containing the caret. A code block is defined
   as a bracket-delimited range of text. Pressing this with a code block
   already selected will select the next outer code block.
  </para>
  <para>
   <guimenu>Edit</>&gt;<guisubmenu>Source Code</>&gt;<guimenuitem>Locate Bracket</> (keyboard
   equivalent: <keycombo><keycap>Control</><keycap>]</></keycombo>)
   will move the caret to the bracket matching the one before the caret.
  </para>
  <para>
   <guimenu>Edit</>&gt;<guisubmenu>Source Code</>&gt;<guimenuitem>Go to Previous Bracket</> (keyboard
   equivalent: <keycombo><keycap>Control</><keycap>Alt</><keycap>[</></keycombo>)
   will move the caret to the previous opening bracket.
  </para>
  <para>
   <guimenu>Edit</>&gt;<guisubmenu>Source Code</>&gt;<guimenuitem>Go to Next Bracket</> (keyboard
   equivalent: <keycombo><keycap>Control</><keycap>Alt</><keycap>]</></keycombo>)
   will move the caret to the next closing bracket.
  </para>
  <para>
   Double clicking on a bracket in the text area will select the code block it
   delimits.
  </para>
  <figure><title>Bracket highlighting in action</>
   <graphic scale=75 fileref=window-editor-bracket></>
  </figure>
 </sect1>
 <sect1 id=indent><title>Tabbing and Indentation</>
  <para>
   A <firstterm>tab</> is a special character that moves the caret to
   the next tab stop. Many programming languages rely
   on tabs to indent lines of source depending on how deeply they
   are nested in the code. jEdit has several features that make
   tabs and indentation easier to deal width.
  </para>
  <sect2 id=indent-tabs><title>Changing the Tab Width</>
   <indexterm><primary>buffer-local properties</>
   <secondary>tabSize</></indexterm>
   <indexterm><primary>tab width</></indexterm>
   <para>
    Many believe that the One True Tab Size is 8, others think that
    all code should be indented with a tab width of 4, and the GNU
    Project refuses to accept code with a tab width of anything but 2.
   </para>
   <para>
    There are three ways to change the tab size:
   </para>
   <itemizedlist>
    <listitem><para>The tab size can be changed on a global basis in
    the Editor pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> dialog box;
    see <xref linkend=global-opts>.</para></listitem>
    <listitem><para>The tab size can be changed in the current buffer
    for the duration of the editing session in the
    <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
   see <xref linkend=buffer-opts>.
    </para></listitem>
    <listitem><para>The tab size can be changed in the current buffer
    for future editing sessions by setting the <quote>tabSize</>
    buffer-local property to the desired tab size, by placing the
    following in one of the first 10 lines of the buffer:
   </para>
   <screen>:tabSize=<replaceable>n</>:</screen>
   <para>
    Where <replaceable>n</> is of course the desired tab size.
    </para></listitem>
   </itemizedlist>
  </sect2>
  <sect2 id=indent-softtabs><title>Soft Tabs</>
   <para>
    <indexterm><primary>soft tabs</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>noTabs</></indexterm>
    Sometimes, it is preferrable to multiple spaces, instead of
    <quote>real</> tabs to indent code. The main advantage of doing so is that
    the file will look the same if viewed with a different default
    tab size. jEdit supports this with its <quote>Soft Tabs</>
    feature. If the <keycap>Tab</> key is pressed with soft tabs enabled,
    the number of spaces necessary to move the caret to the next tab
    stop will be inserted, instead of a <quote>real</> tab.
   </para>
   <para>
    There are three ways to use soft tabs:
   </para>
   <itemizedlist>
    <listitem><para>You can specify if soft tabs should be used
    on a global basis in the
    Editor pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
    dialog box; see <xref linkend=global-opts>.</para></listitem>
    <listitem><para>You can specify if soft tabs should be used
    in the current buffer for
    the duration of the editing session in the
    <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
   see <xref linkend=buffer-opts>.
    </para></listitem>
    <listitem><para>You can specify if soft tabs should be used
    in the current buffer for
    future editing sessions by placing the following in one of the first
    10 lines of the buffer, where <replaceable>flag</> is either
    <command>yes</> or <command>no</>:
    </para>
    <screen>:noTabs=<replaceable>flag</>:</screen>
    </listitem>
   </itemizedlist>
  </sect2>
  <sect2><title>Indentation-Related Commands</>
  <indexterm><primary>selection</></indexterm>
   <para>
    <indexterm><primary>Indent Selected Lines command</></indexterm>
    <indexterm><primary>Lines menu</></indexterm>
    <indexterm><primary>Edit menu</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guisubmenu>Indent
    Selected Lines</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>I</></keycombo>)
    will indent all selected lines (or the current line if there is no
    selection) using the auto indent rules; see
    <xref linkend=autoindent> for details.
   </para>
   <para>
    <indexterm><primary>Go to End Indent command</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guisubmenu>Go to End Indent</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>I</></keycombo>)
    will move the caret to the first non-whitespace character of the current
    line.
   </para>
   <para>
    <indexterm><primary>Shift Indent Left command</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guisubmenu>Shift Indent Left</>
    (keyboard equivalent: <keycombo><keycap>Alt</><keycap>Left Arrow</></keycombo>)
    will remove one level of indent (a tab, or the number of spaces equivalent
    to a tab) from the start of the current line, or every line in the
    selection, if there is one.
   </para>
   <para>
    <indexterm><primary>Shift Indent Right command</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Lines</>&gt;<guisubmenu>Shift Indent Right</>
    (keyboard equivalent: <keycombo><keycap>Alt</><keycap>Right Arrow</></keycombo>)
    will add one level of indent (a tab, or the number of spaces equivalent
    to a tab if soft tabs are enabled) to the start of the current line,
    or every line in the selection, if there is one.
   </para>
   <para>
    <indexterm><primary>soft tabs</></indexterm>
    <indexterm><primary>Spaces to Tabs command</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Spaces to Tabs</>
    will convert
    consecutive spaces to tabs in the selection.
    If no selection is active, it will beep.
   </para>
   <para>
    <indexterm><primary>soft tabs</></indexterm>
    <indexterm><primary>Tabs to Spaces command</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Tabs to Spaces</>
    will convert
    tabs to soft tabs (multiple spaces) in the selection.
    If no selection is active, it will beep.
   </para>
  </sect2>
  <sect2 id=autoindent><title>Automatic Indent</>
   <indexterm><primary>buffer-local properties</>
   <secondary>indentOnEnter</></indexterm>
   <indexterm><primary>buffer-local properties</>
   <secondary>indentOnTab</></indexterm>
   <indexterm><primary>Emacs text editor</></indexterm>
   <indexterm><primary>VIM text editor</></indexterm>
   <para>
    Pressing <keycap>Tab</> or <keycap>Space</> at the start of every
    line to create the appropriate indent is very tedious, so jEdit has
    an auto indent feature.
   </para>
   <para>
    If indent on enter is enabled, pressing the <keycap>Enter</> key
    will create a new line, and insert the appropriate amount of
    indent automatically. This is similar to the way
    <application>VIM</> performs indentation.
   </para>
   <para>
    If indent on tab is enabled, pressing the <keycap>Tab</> key on
    an unindented line will insert the appropriate amount of
    indentation. Pressing it again will insert an actual tab.
    This is similar to the way <application>Emacs</> performs
    indentation.
   </para>
   <para>
    By default, indent on enter is enabled and indent on tab is
    disabled. There are three ways to specify when indentation should be
    performed:
   </para>
   <itemizedlist>
    <listitem><para>Indent on enter and indent on tab can be set on a global
    basis in the Editor pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
    dialog box; see <xref linkend=global-opts>.</para></listitem>
    <listitem><para>Indent on enter and indent on tab can be set in the
    current buffer for the duration of the editing session in the
    <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
   see <xref linkend=buffer-opts>.
    </para></listitem>
    <listitem><para>Indent on enter and indent on tab can be set in the
    current buffer for future editing sessions using buffer-local
    properties by placing the following in the first 10 lines of a buffer,
    where <replaceable>flag</> is either <quote>on</> or <quote>off</>:
    </para>
    <screen>:indentOnEnter=<replaceable>flag</>:indentOnTab=<replaceable>flag</>:</screen>
    </listitem>
   </itemizedlist>
   <para>
    Auto indent rules are mode-specific. In most edit modes,
    the indent of the previous line is simply copied over.
    However, in C-like languages (C, C++, IDL, Java, JavaScript),
    if the previous line contains an open
    curly bracket (<quote>{</>) and you auto indent, an extra tab
    (or soft tab) is inserted.
    Similarly, if you type a
    closing curly bracket (<quote>}</>), a level of indentation is
    removed.
   </para>
   <para>
    If you want to insert a literal tab or newline while indent on tab
    or indent on enter is enabled, prefix the tab or newline with
    <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>V</></keycombo>. For example,
    to create a new line without any indentation, type
    <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>V</></keycombo> <keycap>Enter</>.
   </para>
  </sect2>
 </sect1>
 <sect1 id=commenting><title>Commenting Out Code</>
  <indexterm><primary>selection</></indexterm>
  <para>
   Most programming languages support <quote>comments</>, or regions of
   code which are ignored by the compiler/interpreter. jEdit has several
   commands which make commenting out code slightly easier.
  </para>
  <sect2><title>Wing Comments</>
   <para>
    <indexterm><primary>Wing Comment command</></indexterm>
    <indexterm><primary>Selection menu</></indexterm>
    <indexterm><primary>Edit menu</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>commentStart</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>commentEnd</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Wing Comment</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>C</></keycombo>) will enclose the
    selection with comment start and end strings. An example of C++
    wing commented code looks like so:
   </para>
   <screen>/* Process *proc = Process::getThisProcess();
proc-&gt;getMainThread()-&gt;postMessage(msg);
proc-&gt;getThread("__gui")-&gt;sendPulse(P_WAKE_UP); */</screen>
   <para>
    The strings used for wing commenting can be changed using buffer-local
    properties. For example, placing the following in one of the first 10 lines
    of a buffer will change the wing comment strings to <quote>(*</> and
    <quote>*)</>:
   </para>
   <screen>:commentStart=(*:commentEnd=*):</screen>
  </sect2>
  <sect2><title>Box Comments</>
   <para>
    <indexterm><primary>Box Comment command</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>commentStart</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>commentEnd</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>boxComment</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Box Comment</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>B</></keycombo>) will enclose the
    selection with comment start and end strings, and places the box
    comment string at the start of each line. An example of C++
    box commented code looks like so:
   </para>
   <screen>/* Process *proc = Process::getThisProcess();
* proc-&gt;getMainThread()-&gt;postMessage(msg);
* proc-&gt;getThread("__gui")-&gt;sendPulse(P_WAKE_UP); */</screen>
   <para>
    The strings used for box commenting can be changed using buffer-local
    properties. For example, placing the following in one of the first 10 lines
    of a buffer will change the box comment strings to <quote>(*</> and
    <quote>*</>), with <quote>(-</> placed at the start of each line:
   </para>
   <screen>:commentStart=(*:commentEnd=*):boxComment=(-:</screen>
  </sect2>
  <sect2><title>Block Comments</>
   <para>
    <indexterm><primary>Block Comment command</></indexterm>
    <indexterm><primary>buffer-local properties</>
    <secondary>blockComment</></indexterm>
    <guimenu>Edit</>&gt;<guisubmenu>Selection</>&gt;<guimenuitem>Block Comment</>
    (keyboard equivalent: <keycombo><keycap>Control</><keycap>E</></keycombo>
    <keycombo><keycap>Control</><keycap>K</></keycombo>) will place the
    block comment character at the start of each line in the selection.
    An example of C++ block commented code looks like so:
   </para>
   <screen>// Process *proc = Process::getThisProcess();
// proc-&gt;getMainThread()-&gt;postMessage(msg);
// proc-&gt;getThread("__gui")-&gt;sendPulse(P_WAKE_UP);</screen>
   <para>
    The string used for block commenting can be changed using buffer-local
    properties. For example, placing the following in one of the first 10 lines
    of a buffer will change the box comment string to <quote>--</>:
   </para>
   <screen>:blockComment=--:</screen>
  </sect2>
 </sect1>
 <sect1 id=syntax-hilite><title>Syntax Highlighting</>
  <indexterm><primary>buffer-local properties</>
  <secondary>syntax</></indexterm>
  <indexterm><primary>syntax highlighting</></indexterm>
  <para>
   Syntax highlighting is the display of various syntax tokens using a
   different text style or color. This makes the source easier to follow,
   and makes syntax errors such as misplaced quotes easier to spot.
   All jEdit edit modes except for
   the Plain Text mode perform syntax highlighting.
  </para>
  <para>
   The colors and styles used to highlight syntax tokens can be changed
   in the Colors &amp; Styles pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
   dialog box; see <xref linkend=global-opts>.
  </para>
  <para>
   Syntax highlighting can be enabled or disabled in one of
   the following three ways:
  </para>
  <itemizedlist>
   <listitem><para>You can specify if
   syntax highlighting is to be performed on a global basis in the
   Editor pane of the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
   dialog box;
   see <xref linkend=global-opts>.</para></listitem>
   <listitem><para>You can specify if
   syntax highlighting is to be performed in the current buffer
   for the duration of the editing session in the
   <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> dialog box;
   see <xref linkend=buffer-opts>.
   </para></listitem>
   <listitem><para>You can specify if
   syntax highlighting is to be performed in the current buffer
   for future editing sessions with buffer-local properties by placing
   the following in one of the first 10 lines of the buffer, where
   <replaceable>flag</> is either <quote>on</> or <quote>off</>:
   </para>
   <screen>:syntax=<replaceable>flag</>:</screen>
   </listitem>
  </itemizedlist>
  <figure><title>Syntax highlighting in action</>
   <graphic scale=75 fileref=window-editor-syntax></>
  </figure>
 </sect1>
</chapter>

<chapter id=search-replace><title>Search and Replace</>
 <para>
  jEdit has a very powerful search and replace system. It supports
  multi-file searching and regular expressions, and also a
  <command>grep</>-like <quote>HyperSearch</> feature. This chapter
  covers it in detail.
 </para>
 <sect1 id=quicksearch><title>Searching for Text</>
  <para>
   <indexterm><primary>Find command</></indexterm>
   <indexterm><primary>Search menu</></indexterm>
   <indexterm><primary>history text fields</></indexterm>
   <indexterm><primary>multiple file search and replace</></indexterm>
   <indexterm><primary>regular expressions</></indexterm>
   The <quote>Find</> field in the tool bar can be used to search for text.
   A search string can be entered by clicking the the field, or by invoking
   <guimenu>Search</>&gt;<guimenuitem>Find</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>F</></keycombo>). Pressing <keycap>Enter</> will
   locate the next instance of the currently entered
   string. If <keycap>Enter</> is pressed
   while no string is entered, the Search and Replace dialog box will be
   displayed. Pressing <keycap>Escape</> in the <quote>Find</>
   field will move the focus back to the main text area.
   The find field stores previously entered strings; see
   <xref linkend=history>.
  </para>
  <para>
   The three buttons to the right of the find field can be used to
   toggle case insensitive searching, regular expressions, and multiple
   file searching, respectively. Pressing the first two will toggle the
   respective value, and pressing the multiple file search button will
   display the multifile search options dialog box; see <xref
   linkend=multifile> for details.
  </para>
  <figure><title>The QuickSearch text field and controls</>
   <graphic scale=75 fileref=window-editor-quicksearch></>
  </figure>
  <para>
   <indexterm><primary>selection</></indexterm>
   <indexterm><primary>Find Next command</></indexterm>
   <guimenu>Search</>&gt;<guimenuitem>Find Next</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>G</></keycombo>)
   locates the next instance of the search string.
  </para>
  <para>
   <indexterm><primary>selection</></indexterm>
   <indexterm><primary>Find Selection command</></indexterm>
   <guimenu>Search</>&gt;<guimenuitem>Find Selection</> (keyboard equivalent:
   <keycombo><keycap>Control</><keycap>H</></keycombo>)
   moves the keyboard focus to the <quote>Find</> field in the tool bar
   and inserts any text currently selected in the main text area.
   <keycap>Enter</> can then be pressed to search for that text.
  </para>
  <note>
   <para>
    If the tool bar is disabled, the <guimenuitem>Find</> and
    <guimenuitem>Find Selection</> commands will display the Search and
    Replace dialog box instead.
   </para>
  </note>
 </sect1>
 <sect1 id=search-replace-dlog><title>The Search and Replace Dialog Box</>
  <para>
   <indexterm><primary>Search and Replace command</></indexterm>
   <indexterm><primary>Search menu</></indexterm>
   <indexterm><primary>history text fields</></indexterm>
   <indexterm><primary>multiple file search and replace</></indexterm>
   <indexterm><primary>regular expressions</></indexterm>
   <guimenu>Search</>&gt;<guimenuitem>Search and Replace</>
   (keyboard equivalent: <keycap>F7</>) displays the Search and Replace
   dialog box. The Search and Replace dialog box allows various search
   settings to be changed,
   as well as replacement, unlike the <quote>Find</> field in
   the tool bar.
  </para>
  <itemizedlist>
   <listitem><para>The desired search string can be entered in the
   <guibutton>Find:</> field. This field stores previously entered strings; see
   <xref linkend=history></para></listitem>
   <listitem><para>The desired replacement string can be entered in the
   <guibutton>Replace With:</> field. This field stores previously entered strings; see
   <xref linkend=history>
   </para></listitem>
   <listitem><para>If the <guibutton>Keep Dialog</guibutton> check box
   is selected, the find dialog box will remain open until it is explicitly
   closed. Otherwise,
   it will be closed after a successful search or replace operation.
   </para></listitem>
   <listitem<para>If the <guibutton>Regular Expression</> check box
   is selected, regular expressions can be used to match
   inexact sequences of text; see <xref linkend=regexps>.
   </para></listitem>
   <listitem><para>If the <guibutton>Ignore Case</> check box is selected,
   the search will be case insensitive; entering
   <quote>Hello</> in the search field will locate <quote>hello</>,
   <quote>HELLO</>, and <quote>HeLlO</>
   </para></listitem>
   <listitem><para>If the
   <guibutton>Multi File</> check box is selected,
   multi file searching will be enabled.
   For more information
   about multi-file searching, see <xref linkend=multifile>.
   </para></listitem>
   <listitem><para>Clicking <guibutton>Find</guibutton> or pressing
   <keycap>Enter</> will begin the search. If the search string
   is found, the next occurrence will be selected. If the search
   was unsuccessful, a dialog box will prompt if the search should
   start from the beginning of the buffer (or file set if multi-file
   searching is enabled).
   </para></listitem>
   <listitem><para>Clicking <guibutton>Replace in Selection</>
   will replace all occurrences of the search string with
   the replacement string in the selected text. This will beep
   if there is no selection or if it doesn't contain the search
   string.
   </para></listitem>
   <listitem><para>Clicking <guibutton>Replace All</>
   will replace all occurrences of the search string with
   the replacement string, spanning multiple buffers if
   multi file search is enabled. This will beep
   if the search string could not be found.
   </para></listitem>
   <listitem><para>Clicking <guibutton>Cancel</> will close the search
   and replace dialog box.</para></listitem>
  </itemizedlist>
  <figure><title>The search and replace dialog box</title>
   <graphic scale=75 fileref=dialog-search></>
  </figure>
 </sect1>
 <sect1 id=hypersearch-dlog><title>The HyperSearch Dialog Box</>
  <indexterm><primary>HyperSearch command</></indexterm>
  <indexterm><primary>Search menu</></indexterm>
  <indexterm><primary>history text fields</></indexterm>
  <indexterm><primary>multiple file search and replace</></indexterm>
  <indexterm><primary>regular expressions</></indexterm>
   <para>
   The HyperSearch feature works in a similar fashion to the
   Unix <command>grep</> command - it lists all lines in a set of buffers
   that
   contain a specific string.
  </para>
  <para>
   <guimenu>Search</>&gt;<guimenuitem>HyperSearch</> (keyboard equivalent:
   <keycap>F8</>) displays the HyperSearch dialog box.
  </para>
  <itemizedlist>
   <listitem><para>
    The desired search string can be entered in the
    <guibutton>Find:</> field. This field stores previously entered strings; see
   <xref linkend=history>.
   </para></listitem>
   <listitem><para>
    If the <guibutton>Regular Expression</> check box is selected,
    regular expressions can be used to match inexact sequences of text;
    see <xref linkend=regexps>.
   </para></listitem>
   <listitem><para>
    If the <guibutton>Ignore Case</> check box is
    selected, the search will be case insensitive; entering
    <quote>Hello</> in the search field will locate <quote>hello</>,
    <quote>HELLO</>, and <quote>HeLlO</>
   </para></listitem>
   <listitem><para>
    If the <guibutton>Multi File</> check box is selected, multi file
    searching will be enabled. For more information
    about multi-file searching, see <xref linkend=multifile>.
   </para></listitem>
   <listitem><para>
    Clicking <guibutton>Find All</guibutton> or pressing
    <keycap>Enter</> will list all occurrences of the search
    string. If no occurrences were found, this will beep.
   </para></listitem>
   <listitem><para>Clicking <guibutton>Cancel</> will close the
   HyperSearch dialog box.</para></listitem>
  </itemizedlist>
  <para>
   Once a search has been performed, the results list displays
   all matching lines. Clicking on a line will open the buffer
   where it was found and move the caret to the specified line.
  </para>
  <figure><title>The HyperSearch dialog box</>
   <graphic scale=75 fileref=dialog-hypersearch></>
  </figure>
 </sect1>
 <sect1 id=history><title>History Text Fields</>
  <para>
   <indexterm><primary>history text fields</></indexterm>
   The text fields in the Search and Replace and HyperSearch dialog
   boxes remember the last 25 entered strings.
  </para>
  <para>
   Previous strings can be recalled by pressing
   <keycap>Up Arrow</>. If you have backtracked in the history list,
   <keycap>Down Arrow</> can be used to recall later strings.
  </para>
  <para>
   Pressing <keycombo><keycap>Control</><keycap>Up Arrow</></keycombo>
   or <keycombo><keycap>Control</><keycap>Down Arrow</></keycombo>
   will search backwards or forwards, respectively, for strings
   beginning with the text already entered in the text field. For
   example, if <quote>Th</> is already entered, and the
   strings <quote>Three</>, <quote>Bob</>, <quote>They</>, <quote>Fred</> and
   <quote>Them</> are in the history, pressing
   <keycombo><keycap>Control</><keycap>Up Arrow</></keycombo>
   would recall <quote>Three</>, <quote>They</>, and <quote>Them</>.
  </para>
  <para>
   Clicking the text field with the right mouse button will display
   a pop-up menu of all previously entered strings; selecting one will
   input it into the text field. Holding down <keycap>Control</>
   while clicking will display a menu of all previously entered
   strings that begin with the text already entered; this works
   similarly to holding down <keycap>Control</> with the arrow
   keys.
  </para>
 </sect1>
 <sect1 id=multifile><title>Searching in Multiple Files</>
  <para>
   <indexterm><primary>Multifile Search Settings command</></indexterm>
   <indexterm><primary>Search menu</></indexterm>
   <indexterm><primary>multiple file search and replace</></indexterm>
   jEdit has the ability to search and replace in multiple files.
   To enable multi-file searching, open the Multi File Search
   Settings dialog box, by clicking the <guibutton>Multi File</>
   button in the search and replace or HyperSearch dialog box, or
   by selecting <guimenuitem>Multifile Search Settings</> from
   the <guimenu>Search</> menu.
  </para>
  <para>
   The first two file sets should be self-explanatory. With <quote>Search in
   selected buffers</>, you must <keycap>Control</>-click to select
   multiple buffers from the list.
  </para>
  <para>
   <quote>Search in a directory</> requires you to specify a starting
   path, a glob pattern that file names will be matched against
   (see <xref linkend=globs>), and if the search should recurse into
   subdirectories or not. Keep in mind that the resulting
   search could require a very large number of files to be
   opened, which might take a while, and/or use a large amount of
   RAM.
  </para>
  <para>
   Once you have selected the appropriate buffer set and clicked
   <guibutton>OK</>, any subsequent search and replace operations
   will be performed on all specified buffers.
  </para>
  <warning>
   <para>
    <indexterm><primary>Undo command</></indexterm>
    <indexterm><primary>Edit menu</></indexterm>
    The <guimenuitem>Undo</> command only undoes editing
    done in the current buffer. If a multi-file replace has been
    performed, <guimenuitem>Undo</> will have to be invoked in multiple
    buffers to fully reverse any changes.
   </para>
  </warning>
  <figure><title>The Multi File Search Settings dialog box</>
   <graphic scale=75 fileref=dialog-multifile></>
  </figure>
 </sect1>
</chapter>

<chapter id=customizing><title>Customizing jEdit</>
 <para>
  jEdit has many settings and flags that can be changed, on a global
  or per-buffer basis. This chapter deals with the Buffer Options
  dialog box, the Global Options dialog box, and buffer-local properties.
 </para>
 <sect1 id=buffer-opts><title>The Buffer Options Dialog Box</>
  <indexterm><primary>Buffer Options command</></indexterm>
  <indexterm><primary>Utilities menu</></indexterm>
  <indexterm><primary>edit modes</></indexterm>
  <indexterm><primary>line separator</></indexterm>
  <indexterm><primary>auto indent</></indexterm>
  <indexterm><primary>tab width</></indexterm>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Buffer Options</> displays the
   buffer options dialog box where per-buffer settings can be changed.
   Any changes made in this dialog box are lost when the buffer is
   closed and reopened; it can be used to temporarily test various
   settings or use a different edit mode. See the next section for a
   way to change settings for future editing sessions.
  </para>
  <figure><title>The Buffer Options dialog box</>
   <graphic scale=75 fileref=dialog-bufferopts></>
  </figure>
 </sect1>
 <sect1 id=buffer-local><title>Buffer-Local Properties</>
  <para>
   The Buffer Options dialog box only changes settings
   for the duration of the editing session. It is also possible to
   change settings for all future editing sessions using buffer-local
   properties.
  </para>
  <para>
   When jEdit loads a file, it checks the first 10 lines for
   colon-enclosed name/value pairs. The following example
   will set the tab size to 8 characters, enable soft tabs, and set
   the default edit mode of the file to Perl:
  </para>
  <screen>:noTabs=yes:tabSize=8:mode=perl:</screen>
  <para>
   Buffer-local properties take effect the next time the file is opened.
   The following table lists all valid properties.
   <!-- can't have index terms in table cells... -->
   <indexterm><primary>buffer-local properties</><secondary>blockComment</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>boxComment</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>commentEnd</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>commentStart</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>indentOnEnter</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>indentOnTab</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>indentOpenBrackets</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>indentCloseBrackets</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>maxLineLen</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>mode</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>noTabs</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>noWordSep</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>syntax</></indexterm>
   <indexterm><primary>buffer-local properties</><secondary>tabSize</></indexterm>
  </para>
  <table><title>Table of buffer-local properties</>
   <tgroup cols=2>
    <colspec colnum=1 colwidth=1.5in>
    <thead>
     <row>
      <entry>Property name</>
      <entry>Description</>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>blockComment</>
      <entry>The block comment string. A block comment is one that
      extends to the end of the line. For example, in Java mode the
      default value is <quote>//</>. See <xref linkend=commenting>.</entry>
     </row>
     <row>
      <entry>boxComment</>
      <entry>The box comment string. A box comment is one delimited
      by the wing comment strings, but with the box comment string
      also at the start of each line. For example, in Java mode the
      default value is <quote>*</>. See <xref linkend=commenting>.</entry>
     </row>
     <row>
      <entry>commentEnd</>
      <entry>The wing comment end string. For example, in Java mode
      the default value is <quote>*/</>. See <xref linkend=commenting>.</entry>
     </row>
     <row>
      <entry>commentStart</>
      <entry>The wing comment start string. For example, in Java mode
      the default value is <quote>/*</>. See <xref linkend=commenting>.</entry>
     </row>
     <row>
      <entry>indentOnEnter</>
      <entry>If set to <quote>on</>, indentation will be performed when
      the <keycap>Enter</> key is pressed. See <xref linkend=indent>.</entry>
     </row>
     <row>
      <entry>indentOnTab</>
      <entry>If set to <quote>on</>, indentation will be performed when
      the <keycap>Tab</> key is pressed. See <xref linkend=indent>.</entry>
     </row>
     <row>
      <entry>indentOpenBrackets</>
      <entry>A list of characters (usually brackets) that add indent to
      the <emphasis>next line</>. For example, in Java mode the default value is
      <quote>{</>. See <xref linkend=indent>.</entry>
     </row>
     <row>
      <entry>indentCloseBrackets</>
      <entry>A list of characters (usually brackets) that subtract indent from
      the <emphasis>current</> line. For example, in Java mode the default value is
      <quote>}</>. See <xref linkend=indent>.</entry>
     </row>
     <row>
      <entry>maxLineLen</>
      <entry>The maximum line length, in characters, used by the
      <guimenuitem>Format</> command.</entry>
     </row>
     <row>
      <entry>mode</>
      <entry>The default edit mode for the buffer. The <emphasis>internal</>
      name of the desired mode must be used. See <xref linkend=modes>.</entry>
     </row>
     <row>
      <entry>noTabs</>
      <entry>If set to <quote>yes</>, soft tabs (multiple space characters)
      will be used instead of <quote>real</> tabs. See <xref linkend=indent>.</entry>
     </row>
     <row>
      <entry>noWordSep</>
      <entry>A list of non-alphanumeric characters that are not to
      be treated as word separators. For example, in Java mode the
      default value is <quote>_</> because the underscore can be used
      in Java identifiers, and it is useful to be able to select
      and complete them in one operation.</entry>
     </row>
     <row>
      <entry>syntax</>
      <entry>If set to <quote>on</>, syntax highlighting will be performed.
      See <xref linkend=syntax-hilite>.</entry>
     </row>
     <row>
      <entry>tabSize</>
      <entry>The tab width, in characters. This must be an integer.
      See <xref linkend=indent>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 id=global-opts><title>The Global Options Dialog Box</>
  <indexterm><primary>Global Options command</></indexterm>
  <indexterm><primary>Utilities menu</></indexterm>
  <para>
   <guimenu>Utilities</>&gt;<guimenuitem>Global Options</> displays the
   global options dialog box. A whole slew of settings can be
   customized here. The dialog box is divided into several panes,
   each pane containing a set of related options. To switch between
   panes, use the list on the left of the dialog box. Only panes
   created by jEdit are described here; some plugins add their own option
   panes, and information about them can be found in the plugin documentation.
  </para>
  <sect2><title>The General Pane</>
   <indexterm><primary>line separator</></indexterm>
   <indexterm><primary>backups</></indexterm>
   <indexterm><primary>autosave</></indexterm>
   <para>
    The <guibutton>General</> pane allows you to change the following settings:
   </para>
   <itemizedlist>
    <listitem><para>The Swing look and feel - changes to this settings only
    take effect after jEdit is restarted</para></listitem>
    <listitem><para>Number of recent files to list in the
    <guimenu>File</>&gt;<guisubmenu>Open Recent</> menu</para></listitem>
    <listitem><para>The file encoding used when loading and saving files -
    you can enter any encoding supported by your Java version here, not just
    the ones in the list</para></listitem>
    <listitem><para>The autosave frequency, in seconds - see
    <xref linkend=saving></para></listitem>
    <listitem><para>The maximum number of entires to store in a history list.
    History lists are used by the search and replace features to store
    previously entered search strings. They are also used to store previously
    pasted strings. See <xref linkend=history>, <xref linkend=clipboard> and
    <xref linkend=registers>.</para></listitem>
    <listitem><para>Number of backups to make when saving buffers - if this
    is set to <quote>0</>, no backups will be made at all. If set to
    <quote>1</>, only one backup will be made. Values higher than
    <quote>1</> will cause numbered backups to be enabled, with higher numbers
    being the older versions</para></listitem>
    <listitem><para>The backup directory - if not set, backups will be
    created in the current directory</para></listitem>
    <listitem><para>Backup filename prefix - if set, the specified string will
    be prepended to backup filenames</para></listitem>
    <listitem><para>Backup filename suffix - if set, the specified string will
    be suffixed to backup filenames - at least one of the backup prefix
    and suffix must be set, otherwise interesting things will happen...
    </para></listitem>
    <listitem><para>Default line separator - the line separator/end of line
    characters that will be used for new files. Existing files will always use
    whatever line separator they were found to have on loading. See
    <xref linkend=saving></para></listitem>
    <listitem><para>If the current session should be automatically saved
    and restored when jEdit exits and starts up, respectively. See
    <xref linkend=sessions></para></listitem>
    <listitem><para>If the tool bar/QuickSearch text field should be shown
    </para></listitem>
    <listitem><para>If buffer switching tabs should be shown
    </para></listitem>
    <listitem><para>If the full path of buffers should be shown in view
    title bars, instead of just the name</para></listitem>
    <listitem><para>If the buffer list should be sorted</para></listitem>
    <listitem><para>If the buffer list should be sorted by file name,
    rather than full path name</para></listitem>
   </itemizedlist>
   </sect2>
  <sect2><title>The Editor Pane</>
   <indexterm><primary>tab width</></indexterm>
   <indexterm><primary>auto indent</></indexterm>
   <indexterm><primary>text area</></indexterm>
   <indexterm><primary>caret</></indexterm>
   <indexterm><primary>current line highlighting</></indexterm>
   <indexterm><primary>line highlighting</></indexterm>
   <indexterm><primary>end of line markers</></indexterm>
   <indexterm><primary>electric scrolling</></indexterm>
   <para>
    The <guibutton>Editor</> pane allows you to change the following settings:
   </para>
   <itemizedlist>
    <listitem><para>Default edit mode for new files</para></listitem>
    <listitem><para>Default text font</para></listitem>
    <listitem><para>Default font style</para></listitem>
    <listitem><para>Default font size</para></listitem>
    <listitem><para>Default tab width - see <xref linkend=indent-tabs></para></listitem>
    <listitem><para>If the line with the caret should be drawn with a
    different background</para></listitem>
    <listitem><para>If matching brackets should be highlighted</para></listitem>
    <listitem><para>If a faint dot should be drawn at the end of each line</para></listitem>
    <listitem><para>If lines that are visible but are not actually in the
    buffer should be drawn as red tildes - if not set, they will be drawn
    as empty lines</para></listitem>
    <listitem><para>If syntax highlighting should be performed</para></listitem>
    <listitem><para>If the current line should be indented when
    <keycap>Tab</> is pressed - see <xref linkend=autoindent></para></listitem>
    <listitem><para>If the correct indentation should automatically be
    inserted when
    <keycap>Enter</> is pressed - see <xref linkend=autoindent></para></listitem>
    <listitem><para>If spaces should be used instead of <quote>real</> tabs
    for indentation - see <xref linkend=indent-softtabs></para></listitem>
    <listitem><para>If the caret should blink</para></listitem>
    <listitem><para>If the caret should be drawn as a block or a vertical
    line</para></listitem>
    <listitem><para>If placing the caret on the first three or last three
    visible lines should automatically scroll</para></listitem>
    <listitem><para>In the <keycap>Home</> and <keycap>End</> should move
    the caret to the start/end of the viewport and buffer when pressed
    repeatedly - see <xref linkend=caret></para></listitem>
   </itemizedlist>
  </sect2>
  <sect2><title>The Colors &amp; Styles Pane</>
   <indexterm><primary>syntax highlighting</></indexterm>
   <indexterm><primary>text area</></indexterm>
   <indexterm><primary>caret</></indexterm>
   <indexterm><primary>current line highlighting</></indexterm>
   <indexterm><primary>line highlighting</></indexterm>
   <indexterm><primary>end of line markers</></indexterm>
   <indexterm><primary>invalid lines</></indexterm>
   <para>
    The <guibutton>Colors &amp; Styles</> pane allows you to change various
    colors used by the text area, and the text styles used by syntax
    highlighting. Clicking on a color or style will display the appropriate
    editor for changing it.
   </para>
  </sect2>
  <sect2><title>The File Filters Pane</>
   <para>
    The <guibutton>File Filters</> pane allows you to add custom file filters
    to the open file and save dialog boxes. Note that the file filters
    built into jEdit (the ones for the standard editing modes) cannot
    be changed; only user-defined file filters can be added and changed.
   </para>
   <para>
    Filters are added and removed in a rather peculiar fashion in this pane.
    Changing the last line in the list (which is always blank) will add
    another blank line. Lines with empty names or globs will
    be ignored when the filters are being saved.
   </para>
   <para>
    The glob patterns are case insensitive. For information about
    glob patterns, which are a simplified form of regular expressions,
    see <xref linkend=globs>.
   </para>
  </sect2>
  <sect2 id=options-shortcuts><title>The Shortcut Editing Panes</>
  <indexterm><primary>keyboard shortcuts</>
  <secondary>customizing</></indexterm>
   <para>
    The <guibutton>Command Shortcuts</> pane allows you to change key
    bindings for jEdit's commands. The <guibutton>Macro Shortcuts</> pane
    allows you to change macro key bindings.
   </para>
   <para>
    Internally, jEdit stores key bindings in the form
    <replaceable>modifiers</>+<replaceable>key</> where <replaceable>modifiers</>
    is a list of modifiers, with C being Control, A being Alt, and S being
    Shift. <replaceable>key</> is either an alphanumeric character, or a
    named key stroke such as <keycap>PAGE_UP</>. A full list of named
    key strokes is available in the API documentation for the
    <filename>java.awt.event.KeyEvent</> class.
   </para>
   <para>
    jEdit also allows multiple keystroke bindings; for example,
    <guimenuitem>Open URL</> is bound to <keycap>C+e C+o</>. Any number
    of keystrokes can be present in a key binding. If you are having
    trouble finding an unused key binding, try using one of the function
    keys plus a modifier such as <keycap>Control</> or <keycap>Alt</>.
   </para>
   <para>
    Changes to the key bindings take effect immediately, but due to a
    quirk in jEdit's menu bar implementation, menu item labels will contain
    the old shortcuts until jEdit is restarted.
   </para>
  </sect2>
  <sect2><title>The Abbreviations Pane</>
   <para>
    The <guibutton>Abbreviations</> pane allows you to enable or disable
    automatic abbreviation expansion, and edit the defined abbrevs.
   </para>
   <para>
    The combo box labelled <quote>Abbrev set</> is used to choose the
    abbrev set to edit. The first entry, <quote>global</>, allows you to
    edit abbrevs available in all edit modes. The subsequent
    entries allow you to edit abbrevs on a per-mode basis.
   </para>
   <para>
    Abbrevs are added and removed in a rather peculiar fashion in this pane.
    Changing the last line in the list (which is always blank) will add
    another blank line. Lines with empty abbrevs or expansions will
    be ignored when the abbrevs are being saved.
   </para>
   <figure><title>The General pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-general></>
   </figure>
   <figure><title>The Editor pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-editor></>
   </figure>
   <figure><title>The Colors &amp; Styles pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-styles></>
   </figure>
   <figure><title>The File Filters pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-filters></>
   </figure>
   <figure><title>The Command Shortcuts pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-cmd-shortcuts></>
   </figure>
   <figure><title>The Macro Shortcuts pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-mac-shortcuts></>
   </figure>
   <figure><title>The Abbreviations pane of the Global Options dialog box</>
    <graphic scale=75 fileref=dialog-options-abbrevs></>
   </figure>
  </sect2>
 </sect1>
</chapter>

<chapter id=plugins><title>Installing and Using Plugins</>
 <para>
  jEdit supports plugins, loadable modules of code that extend the
  editor's functionality. This chapter covers installation and usage
  of plugins; information on developing plugins is in the next
  chapter.
 </para>
 <sect1 id=installing-plugins><title>Installing Plugins</>
  <indexterm><primary>.jedit/jars directory</></indexterm>
  <indexterm><primary>JAR (Java Archive) files</></indexterm>
  <indexterm><primary>Help menu</></indexterm>
  <indexterm><primary>Show Activity Log command</></indexterm>
  <para>
   When jEdit starts up, it prints a number of messages detailing the
   plugin load process to the activity log. To view the log,
   select <guimenu>Help</>&gt;<guimenuitem>Show Activity Log</>.
   Here is an example:
  </para>
  <screen>[message] jEdit: Scanning directory: /usr/local/jedit-2.2pre2/jars
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/buffertabs.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/Console.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/EditBus.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/HTML.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/JBrowse.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/LatestVersion.jar
[debug] jEdit: Scanning JAR file: /usr/local/jedit-2.2pre2/jars/quickfile.jar
[message] jEdit: Scanning directory: /home/slava/.jedit/jars
[debug] jEdit: Scanning JAR file: /home/slava/.jedit/jars/TextTools.jar
[notice] JARClassLoader: Starting plugin BufferTabsPlugin
[notice] JARClassLoader: Starting plugin ConsolePlugin
[notice] JARClassLoader: Starting plugin EditBusPlugin
[notice] JARClassLoader: Starting plugin HTMLPlugin
[notice] JARClassLoader: Starting plugin JBrowsePlugin
[notice] JARClassLoader: Starting plugin LatestVersionPlugin
[notice] JARClassLoader: Starting plugin QuickFilePlugin
[notice] JARClassLoader: Starting plugin TextToolsPlugin</screen>
  <para>
   jEdit scans two directories for plugins on startup;
   the system-wide plugin directory, where plugins that are to be available
   to all users can be placed, and the user-specific plugin
   directory, where plugins for a specific user can be installed.
  </para>
  <para>
   Plugins are distributed as ZIP or GZipped TAR files. Uncompressing
   them will result in a JAR file which contains the plugin's code and
   resources, and a directory which contains the source code. Only the JAR
   file is required by jEdit; the source code is for developers and the
   curious.
  </para>
 </sect1>
 <sect1 id=dependency-errors><title>Dependency Errors</>
  <indexterm><primary>dependency errors</></indexterm>
  <indexterm><primary>Help menu</></indexterm>
  <indexterm><primary>Show Activity Log command</></indexterm>
  <para>
   If jEdit detects that some plugin requires some capability
   that is not currently available, the plugin will not be loaded,
   and instead a
   <quote>dependency error</> will be printed in the activity
   log (<guimenu>Help</>&gt;<guimenuitem>Show Activity Log</>) and
   system console.
  </para>
  <screen>[error] JARClassLoader: ConsolePlugin requires jEdit 2.2final
[error] JARClassLoader: ErrorListPlugin requires class EditBusPlugin
[error] JARClassLoader: XInsertPlugin requires JDK 1.2</screen>
 </sect1>
 <sect1 id=using-plugins><title>Using Plugins</>
  <indexterm><primary>Plugins menu</></indexterm>
  <indexterm><primary>Global Options command</></indexterm>
  <indexterm><primary>Utilities menu</></indexterm>
  <indexterm><primary>Help Contents command</></indexterm>
  <indexterm><primary>Help menu</></indexterm>
  <para>
   Exactly how a plugin can be used of course depends on the plugin. The
   first place to look in should probably be the plugin's help; plugins
   with documentation are listed in the <guimenu>Help</> menu. Some
   plugins might not have any documentation, however.
  </para>
  <para>
   Most plugins add submenus or menu items to the <guimenu>Plugins</> menu.
   Some plugins with customizable options add panes to the
   <guimenu>File</>&gt;<guimenuitem>Global Options</> dialog box.
  </para>
 </sect1>
</chapter>

<chapter id=developing-plugins><title>Developing Plugins</>
 <para>
  This chapter overviews jEdit plugin development. A knowledge
  of Java, Swing, and JDK tools (<application>javac</>,
  <application>jar</>, and so on) is assumed. This chapter
  is meant to be read together with the jEdit API documentation; the
  text in this chapter presents brief <quote>cookbook</>-style instructions
  for the most common tasks, while the API documentation gives more
  detail and in-depth coverage - if you know what you're looking for.
  And of course, learning any sort of programming is difficult unless you
  look at examples and experiment; having the source to a couple of
  plugins will definitely help.
 </para>
 <para>
  This section is still under construction; more is still to come.
 </para>
 <sect1 id=plugin-jar><title>General Structure of a Plugin</>
  <para>
   A plugin is a JAR (Java Archive) file that adds to or modifies jEdit's
   functionality. The JAR file can contain class files, property files
   (more on that later), or any other file type, such as images, and so on.
  </para>
  <para>
   jEdit handles the loading of property and class files from plugins
   automatically, but other file types such as images can be fetched
   with the <function>getResource()</> method of the <classname>Class</>
   class.
  </para>
  <para>
   Plugins can use classes loaded from other plugins; for example,
   the <quote>EditBus</> plugin provides enhanced communication
   services, which other plugins can use.
  </para>
 </sect1>
 <sect1 id=plugin-class><title>The EditPlugin Class</>
  <para>
   At the heart of every plugin is an implementation of the
   <classname>org.gjt.sp.jedit.EditPlugin</> class. It registers the plugin's
   actions and edit modes with jEdit, takes care of setting up the
   plugin's menus and menu items, and so on. When a plugin JAR is
   loaded, jEdit scans for any class files whose names end with
   <filename>Plugin</> (for example, <filename>FooPlugin</>). Those classes
   are instantiated and added to jEdit's plugin list.
  </para>
  <indexterm><primary>class</><secondary>EditPlugin</></indexterm>
  <bridgehead renderas=sect3>EditPlugin class</>
  <programlisting>public abstract class EditPlugin
{
        public void start();
        public void stop();
        public void createMenuItems(Vector menuItems, Vector menus);
        public void createOptionPanes(OptionsDialog optionsDialog);
}</programlisting>
  <indexterm><primary>method</><secondary>start() of EditPlugin class</></indexterm>
  <bridgehead renderas=sect3>EditPlugin.start() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>void <function>start</></funcdef>
    <void>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is responsible for adding actions and edit modes to jEdit,
   and doing other initialization tasks. It is called at the end of
   the jEdit startup sequence, after all plugins are loaded (so by the time this
   method is called, classes from
   other plugins are available, and so on). Most plugins will want to
   override this method and so some initialization.
  </para>
  <indexterm><primary>method</><secondary>stop() of EditPlugin class</></indexterm>
  <bridgehead renderas=sect3>EditPlugin.stop() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>void <function>stop</></funcdef>
    <void>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is called just before jEdit exits. Overriding it is rarely
   necessary.
  </para>
 </sect1>
 <sect1 id=plugin-props><title>Plugin Properties</>
  <para>
   Plugins can use property files to store name/value pairs. Possible name/value
   pairs include human-readable strings, settings for
   the plugin, and so on. Certain properties can also
   contain information for use by jEdit.
  </para>
  <para>
   When a plugin JAR is being loaded, all files with extension
   <filename>.props</> are read into jEdit's property list. Property
   files have a very simple syntax. Each line either starts with a
   hash (<quote>#</>) in which case it is a comment and is ignored,
   or contains a name/value pair with an equals sign (<quote>=</>)
   separating the name and value. Here is a simple example:
  </para>
  <programlisting># Property file for a non-existent 'FooPlugin'
# Some properties with well-known names are queried by jEdit
plugin.FooPlugin.name=Wonderful Foo Plugin
plugin.FooPlugin.version=18.27beta9

# Properties with arbitrary names can also be used by a plugin for
# storing strings and user preferences
foo.baz=Hello World
qux=$</programlisting>
  <para>
   Various static methods in the <classname>jEdit</> class can be used
   to manipulate properties.
  </para>
  <indexterm><primary>class</><secondary>jEdit</></indexterm>
  <indexterm><primary>method</><secondary>getProperty() of jEdit class</></indexterm>
  <bridgehead renderas=sect3>jEdit.getProperty() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public static String <function>getProperty</></funcdef>
    <paramdef>String <parameter>name</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public static String <function>getProperty</></funcdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>Object[] <parameter>args</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method returns the value of the named property. If the second form
   is used, elements of <parameter>args</> array will be substituted every
   time a string of the form <property>{<replaceable>n</>}</> occurs in the
   property value. For example,
   the below code will produce the output <computeroutput>Hello, World</> if the
   value of the <property>foo</> property is <property>{1}, {2}</>:
  </para>
  <programlisting>Object[] args = { "Hello", "World" };
System.out.println(jEdit.getProperty("foo",args));</>
  <para>
   Under the hood, this form of <function>getProperty()</> uses
   <classname>java.text.MessageFormat</> to do the formatting, and so
   supports many of MessageFormat's features. See the appropriate API
   documentation for details.
  </para>
  <indexterm><primary>method</><secondary>setProperty() of jEdit class</></indexterm>
  <bridgehead renderas=sect3>jEdit.setProperty() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public static String <function>setProperty</></funcdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>String <parameter>value</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method sets the value of the specified named property. Once a
   property is set with this method, it will be saved to the user
   properties file (the original property files in the JAR are never
   modified) and its value will be persistent for future sessions.
   To set properties which are not persistent, see the next method.
  </para>
  <indexterm><primary>method</><secondary>setDefaultProperty() of jEdit class</></indexterm>
  <bridgehead renderas=sect3>jEdit.setDefaultProperty() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public static String <function>setDefaultProperty</></funcdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>String <parameter>value</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is similar to <function>setProperty()</>, except that it
   sets the property in the default property list, which means it will not
   be saved to the user properties file. This can be used to set properties
   that are only to remain for the duration of the current editing session.
  </para>
 </sect1>
 <sect1 id=plugin-info><title>Plugin Documentation</>
  <para>
   Unless your plugin does something extremely trivial,  providing
   documentation is probably a good idea. For your plugin to appear
   in jEdit's help index, you must define the following properties, where
   <replaceable>plugin</> is the class name of your <classname>EditPlugin</>
   implementation:
  </para>
  <itemizedlist>
   <listitem><para>
    <property>plugin.<replaceable>plugin</>.name</property> - the name
    of the plugin
   </para></listitem>
   <listitem><para>
    <property>plugin.<replaceable>plugin</>.author</property> - the plugin
    author's name
   </para></listitem>
   <listitem><para>
    <property>plugin.<replaceable>plugin</>.version</property> - the plugin
    version (this can be in any format you like, it is only used in the
    help system)
   </para></listitem>
   <listitem><para>
    <property>plugin.<replaceable>plugin</>.docs</property> - the filename,
    relative to the plugin's JAR root, where the documentation is stored in
    HTML format
   </para></listitem>
  </itemizedlist>
  <para>
   All these properties must be defined for your plugin to be listed in the
   help system. Here is an example:
  </para>
  <screen>plugin.ConsolePlugin.name=Console
plugin.ConsolePlugin.author=Slava Pestov
plugin.ConsolePlugin.version=1.9.3
plugin.ConsolePlugin.docs=index.html</>
 </sect1>
 <sect1 id=plugin-dependencies><title>Plugin Dependencies</>
  <para>
   You can use plugin dependencies to prevent your plugin from loading on
   versions of jEdit and the JDK earlier than you specify. This should be
   used if your plugin uses features specific to those versions, to
   prevent people with earlier software from seeing endless streams of
   exceptions.
  </para>
  <para>
   Before a plugin is loaded, jEdit checks any dependency properties
   defined by the plugin. These properties are named
   <property>plugin.<replaceable>plugin</>.depend.<replaceable>n</></>,
   where <replaceable>plugin</> is the class name of your
   <classname>EditPlugin</> implementation, and <replaceable>i</> is an index.
   The indexing of the dependencies must start at 0 and be consecutive.
  </para>
  <para>
   To add a dependency for a specific JDK version, specify <quote>jdk</>,
   followed by a version number as the value of a dependency property.
   To depend on a specific jEdit release, specify <quote>jedit</> followed
   by the <firstterm>build number</>. The build number of a jEdit release
   can be found in the <filename>org/gjt/sp/jedit/jEdit.java</> file.
  </para>
  <para>
   Here is a typical example for a plugin that requires JDK 1.2 and
   jEdit 2.1pre3:
  </para>
  <programlisting>plugin.BazPlugin.depend.0=jdk 1.2
plugin.BazPlugin.depend.1=jedit 02.02.03.00</>
  <para>
   How do you know exactly which jEdit version your plugin requires?
   The EditPlugin API was added in jEdit 2.1pre1 (build 02.01.01.00), so all
   current
   plugins will require at least that version. The option pane API changed
   in jEdit 2.1pre3 (build 02.01.03.00), so plugins
   using option panes will require that. Finally, another major change
   occurred in jEdit 2.2pre6 (build 02.02.06.00); the EditBus message
   system was integrated into the core. There have been many other smaller
   API changes along the way,
   but most don't affect plugins.
  </para>
 </sect1>
 <sect1 id=plugin-actions><title>Plugin Actions</>
  <para>
   An <firstterm>action</> is basically an AWT action listener with a
   <quote>name</>
   attached. The name is used to obtain several properties, such as the
   action's menu item label and such. Actions are called by jEdit
   in response
   to user feedback such as menu item selections, keystrokes, etc.
  </para>
  <indexterm><primary>class</><secondary>EditAction</></indexterm>
  <bridgehead renderas=sect3>EditAction class</>
  <programlisting>public abstract class EditAction implements ActionListener
{
        public EditAction(String name);
        public String getName();
        public boolean isToggle();
        public boolean isSelected(Component comp);
        public abstract void actionPerformed(ActionEvent evt);
        public static Buffer getBuffer(ActionEvent evt);
        public static View getView(Component comp);
        public static View getView(ActionEvent evt);
}</programlisting>
  <para>
   The <classname>org.gjt.sp.jedit.EditAction</> class is the base class for
   all actions.
   It allows actions to be named, and provides methods for obtaining the
   view and buffer that invoked the action. It implements the
   <classname>java.awt.event.ActionListener</> interface, and hence can be
   used anywhere an ordinary action listener would, for example to
   handle menu item and button clicks.
  </para>
  <bridgehead renderas=sect3>EditAction.EditAction() constructor</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public <function>EditAction</></funcdef>
    <paramdef>String <parameter>name</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   The constructor for the <classname>EditAction</> class takes the action
   name as a parameter. Concrete implementations of this class should
   provide a constructor with no parameters.
  </para>
  <para>
   jEdit's built-in actions have all-lower case names, with multiple words
   separated by dashes (<quote>-</>). You should follow this convention
   in your own plugins, too.
  </para>
  <indexterm><primary>method</><secondary>isToggle() of EditAction class</></indexterm>
  <bridgehead renderas=sect3>EditAction.isToggle() method</>
  <funcsynopsis>
   <funcprototype>
    <funcdef>public void <function>isToggle</></funcdef>
    <void>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method returns true if the action should be represented as a check
   box menu item, false if it should be a normal menu item. By default, it
   returns <command>false</>; override it to return <command>true</> if you
   want the action to be a toggle.
  </para>
  <indexterm><primary>method</><secondary>isSelected() of EditAction class</></indexterm>
  <bridgehead renderas=sect3>EditAction.isSelected() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.Component;</>
   <funcprototype>
    <funcdef>public void <function>isToggle</></funcdef>
    <paramdef>Component <parameter>comp</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is only called if <function>isToggle()</> returns
   <command>true</>. It should return if the menu item's check box should be
   selected. <parameter>comp</> is the component performing the query;
   for example,
   if the menu item state is determined on a per-view basis, you can pass
   the component to the <function>getView()</> method to obtain the
   current view instance.
  </para>
  <indexterm><primary>method</><secondary>actionPerformed() of EditAction class</></indexterm>
  <bridgehead renderas=sect3>EditAction.actionPerformed() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.event.ActionEvent;</>
   <funcprototype>
    <funcdef>public abstract void <function>actionPerformed</></funcdef>
    <paramdef>ActionEvent <parameter>evt</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This abstract method must be implemented to do the work of the action.
   To obtain the view or buffer instance that invoked this action,
   pass the <parameter>evt</> event instance to the
   <function>getView()</> or <function>getBuffer()</> methods,
   respectively.
  </para>
  <indexterm><primary>class</><secondary>jEdit</></indexterm>
  <indexterm><primary>method</><secondary>addAction() of jEdit class</></indexterm>
  <bridgehead renderas=sect3>jEdit.addAction() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.EditAction;</>
   <funcprototype>
    <funcdef>public static void <function>addAction</></funcdef>
    <paramdef>EditAction <parameter>action</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method adds the action to jEdit's action list, making it available
   to the <function>GUIUtilities.loadMenuItem()</> method, and so on.
   Plugin should add their actions to jEdit in their
   <function>start()</> methods.
  </para>
 </sect1>
 <sect1 id=plugin-menus><title>The Plugins Menu</>
  <para>
   When a view is created, it queries all installed plugins for any menus
   and menu items they want to add to the Plugins menu.
  </para>
  <para>
   While creating new
   <classname>JMenuItem</> and <classname>JMenu</> instances
   with hardcoded labels might seem like the easy way out,
   in reality it is not a good idea because the resulting plugin is
   inflexible and not easily localizable. This chapter describes
   how to do it the jEdit way.
  </para>
  <indexterm><primary>class</><secondary>EditPlugin</></indexterm>
  <indexterm><primary>method</><secondary>createMenuItems() of EditPlugin class</></indexterm>
  <bridgehead renderas=sect3>EditPlugin.createMenuItems() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.util.Vector;
import org.gjt.sp.jedit.View;</>
   <funcprototype>
    <funcdef>void <function>createMenuItems</></funcdef>
    <paramdef>View <parameter>view</></paramdef>
    <paramdef>Vector <parameter>menus</></paramdef>
    <paramdef>Vector <parameter>menuItems</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   Newly created views call this method of each plugin in turn. The default
   implementation does nothing, but most plugins will want to override it
   to add instances of <classname>javax.swing.JMenu</>
   and <classname>javax.swing.JMenuItem</> to
   the appropriate vectors. While you could create instances of
   <classname>JMenu</> and <classname>JMenuItem</> directly,
   the preferred
   way is to use the
   methods of the <classname>GUIUtilities</> class.
  </para>
  <indexterm><primary>class</><secondary>GUIUtilities</></indexterm>
  <indexterm><primary>method</><secondary>loadMenu() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.loadMenu() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import javax.swing.JMenu;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.View;</>
   <funcprototype>
    <funcdef>public static JMenu <function>loadMenu</></funcdef>
    <paramdef>View <parameter>view</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   The <function>loadMenu()</> method loads a menu from the properties.
   It obtains the menu from the following properties:
  </para>
  <itemizedlist>
   <listitem><para><property><replaceable>name</>.label</property>:
   the menu label, as it will appear in the <guimenu>Plugins</> menu
   </para></listitem>
   <listitem><para><property><replaceable>name</></property>:
   a whitespace separated list of action names that are to appear in the
   menu. A dash (<quote>-</>) in the list will insert a menu separator
   </para></listitem>
  </itemizedlist>
  <indexterm><primary>class</><secondary>GUIUtilities</></indexterm>
  <indexterm><primary>method</><secondary>loadMenuItem() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.loadMenuItem() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import javax.swing.JMenuItem;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.View;</>
   <funcprototype>
    <funcdef>public static JMenuItem <function>loadMenuItem</></funcdef>
    <paramdef>View <parameter>view</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   The <function>loadMenuItem()</> loads a menu item from the properties.
   It is bound to the action named <parameter>name</>, and the menu item
   label is loaded from the property named
   <property><replaceable>name</>.label</property>.
  </para>
  <note>
   <para>
    While you might be tempted to assign convenient keyboard shortcuts
    to your plugin's actions, doing so
    is highly discouraged, for several reasons.
    First of all, if two plugins bind to the
    same key, nothing good will happen. Secondly, future jEdit versions
    might use your shortcuts. It is much better to let the user decide
    which plugins they actually use, and assign whatever shortcuts
    they want to them.
   </para>
  </note>
 </sect1>
 <sect1 id=plugin-options><title>The Global Options Dialog Box</>
  <para>
   The Global Options dialog box is a common location for changing editor-wide
   settings, including plugin settings.
   Each pane in the dialog box is actually an implementation of the
   <classname>org.gjt.sp.jedit.OptionPane</> interface - though most plugins
   will subclass the <classname>org.gjt.sp.jedit.AbstractOptionPane</> class
   which provides a default layout implementation.
  </para>
  <indexterm><primary>interface</><secondary>OptionPane</></indexterm>
  <indexterm><primary>class</><secondary>AbstractOptionPane</></indexterm>
  <bridgehead renderas=sect3>OptionPane class</>
  <programlisting>public abstract class AbstractOptionPane extends JPanel
implements OptionPane
{
        public OptionPane(String name);
        public String getName();
        public void save();
        public void addComponent(String label, Component comp);
        public void addComponent(Component comp);
}</programlisting>
  <para>
   Because
   most plugins will want to use the <classname>AbstractOptionPane</> class,
   instead of the <classname>OptionPane</> interface; only the former will
   be covered here.
   Each <classname>AbstractOptionPane</> instance, like many other jEdit objects,
   has a unique
   <quote>name</> which is used to query properties.
   The only option pane property currently used is
   <property>options.<replaceable>name</>.label</property>, which stores
   the label for the option pane in the options dialog box.
  </para>
  <para>
   The two <function>addComponent()</> methods can be used to add components
   to the option pane using the default layout manager. Nothing prevents you
   from calling <function>setLayout()</> and <function>add()</> to implement
   your own appearance, though.
  </para>
  <indexterm><primary>class</><secondary>OptionsDialog</></indexterm>
  <indexterm><primary>method</><secondary>addOptionPane() of OptionsDialog class</></indexterm>
  <bridgehead renderas=sect3>OptionsDialog.addOptionPane() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.OptionPane;</>
   <funcprototype>
    <funcdef>public void <function>addOptionPane</></funcdef>
    <paramdef>OptionPane <parameter>pane</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   The <function>addOptionPane()</> method adds the specified option pane to an
   options dialog instance. You will almost always call this method from a
   plugin's <function>createOptionPanes()</> method, which is invoked every
   time the Plugin Options dialog box is displayed.
  </para>
  <indexterm><primary>class</><secondary>EditPlugin</></indexterm>
  <indexterm><primary>method</><secondary>createOptionPanes() of EditPlugin class</></indexterm>
  <bridgehead renderas=sect3>EditPlugin.createOptionPanes() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.OptionsDialog;</>
   <funcprototype>
    <funcdef>public void <function>createOptionPanes</></funcdef>
    <paramdef>OptionsDialog <parameter>dialog</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   The Plugin Options dialog box invokes the
   <function>createOptionPanes()</> method of each plugin when it is being
   displayed. The canonical implementation
   would add a new <classname>OptionPane</> instance to the options dialog
   using the <function>addOptionPane()</> method.
  </para>
 </sect1>
 <sect1 id=plugin-dialogs><title>Canned Dialog Boxes</>
  <para>
   The Swing <classname>JOptionPane</> class is a great way to present
   simple
   messages and errors to the user, but it has two drawbacks:
  </para>
  <itemizedlist>
   <listitem><para>No support for localization; you must call
   <function>jEdit.getProperty()</> manually for each element of
   the message</para></listitem>
   <listitem><para>Too complicated; the various methods of the
   <classname>JOptionPane</> class have too many parameters which
   are hard to get right</para></listitem>
  </itemizedlist>
  <para>
   To solve this, jEdit has a number of wrappers around the
   <classname>JOptionPane</> class in the <classname>GUIUtilities</> class
   that simplify creation of canned dialog boxes.
  </para>
  <indexterm><primary>class</><secondary>GUIUtilities</></indexterm>
  <indexterm><primary>method</><secondary>message() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.message() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.Frame;</>
   <funcprototype>
    <funcdef>public static void <function>message</></funcdef>
    <paramdef>Frame <parameter>frame</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>Object[] <parameter>args</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method displays a message dialog box with title obtained from the
   property
   <property><replaceable>name</>.title</property> and
   message from the property <property><replaceable>name</>.message</property>.
   Elements of the <parameter>args</> array are substituted into
   the message; see <xref linkend=plugin-props> for details.
  </para>
  <indexterm><primary>method</><secondary>error() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.error() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.Frame;</>
   <funcprototype>
    <funcdef>public static void <function>error</></funcdef>
    <paramdef>Frame <parameter>frame</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>Object[] <parameter>args</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method displays an error dialog box. The only difference
   between a message and error dialog box is the icon
   displayed. Otherwise it is exactly the same as a message.
  </para>
  <indexterm><primary>method</><secondary>input() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.input() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.Frame;</>
   <funcprototype>
    <funcdef>public static String <function>input</></funcdef>
    <paramdef>Frame <parameter>frame</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>String <parameter>defaultValue</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method displays an input dialog box with title obtained from the
   property
   <property><replaceable>name</>.title</property> and
   message from the property <property><replaceable>name</>.message</property>.
   An input dialog box is similar to a message, except that a text field is
   added where the user can type a one-line string.
   The <parameter>defaultValue</> parameter is the
   initial contents of the text field.
   When the user enters a value and clicks <guibutton>OK</>,
   the currently entered
   value is returned. If they click <guibutton>Cancel</>, the
   method returns <command>null</>.
  </para>
  <indexterm><primary>method</><secondary>inputProperty() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.inputProperty() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import java.awt.Frame;</>
   <funcprototype>
    <funcdef>public static String <function>inputProperty</></funcdef>
    <paramdef>Frame <parameter>frame</></paramdef>
    <paramdef>String <parameter>name</></paramdef>
    <paramdef>String <parameter>property</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is exactly the same as <function>input()</> except that
   the value entered by the user is automatically stored in
   the property named <parameter>property</>.
  </para>
  <indexterm><primary>method</><secondary>showFileDialog() of GUIUtilities class</></indexterm>
  <bridgehead renderas=sect3>GUIUtilities.showFileDialog() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.View;</>
   <funcprototype>
    <funcdef>public static String <function>showFileDialog</></funcdef>
    <paramdef>View <parameter>view</></paramdef>
    <paramdef>String <parameter>file</></paramdef>
    <paramdef>int <parameter>type</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method is a wrapper around the <classname>JFileChooser</> class.
   It displays a file chooser dialog, with the file named
   <parameter>file</> selected. The <parameter>type</> parameter is
   either <command>JFileChooser.OPEN_DIALOG</> or
   <command>JFileChooser.SAVE_DIALOG</>. This method returns
   <command>null</> if the user clicks <guibutton>Cancel</>, otherwise the
   selected pathname is returned.
  </para>
 </sect1>
 <sect1 id=plugin-logging><title>The Activity Log</>
  <para>
   In some circumstances, for example while jEdit is starting up,
   it may not practical to call <function>GUIUtilities.message()</>
   and <function>GUIUtilities.error()</> for every message and
   error that comes up. In those cases, you probably want to print
   the messages
   to some sort of log that the user can review later.
   While <function>System.out.println()</> and friends may
   seem like an obvious choice for this task, it
   is not always the best, for the following reasons:
  </para>
  <itemizedlist>
   <listitem><para>
    The user might not want to keep a system console window open to watch jEdit
    messages
   </para></listitem>
   <listitem><para>
    People who use the console might get annoyed if you print too
    many messages
   </para></listitem>
   <listitem><para>
    People trying to debug the plugin might find that it doesn't print
    enough information
   </para></listitem>
   <listitem><para>
    There is no easy way to save a plugin's output (on Unix you can
    select output in an X terminal with the mouse and copy it, but this
    is not possible on Windows).
   </para></listitem>
  </itemizedlist>
  <para>
   To overcome these problems, jEdit has its own logging API.
  </para>
  <indexterm><primary>class</><secondary>Log</></indexterm>
  <indexterm><primary>method</><secondary>log() of Log class</></indexterm>
  <bridgehead renderas=sect3>Log.log() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.util.Log;</>
   <funcprototype>
    <funcdef>public static void <function>log</></funcdef>
    <paramdef>int <parameter>urgency</></paramdef>
    <paramdef>Object <parameter>source</></paramdef>
    <paramdef>Object <parameter>message</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method appends a message to the activity log
   (see <xref linkend=activity-log>).
   <parameter>urgency</> is one of
   <command>Log.DEBUG</>,
   <command>Log.MESSAGE</>,
   <command>Log.NOTICE</>,
   <command>Log.WARNING</>, or
   <command>Log.ERROR</>. Messages with an urgency below
   <command>Log.WARNING</> are only printed in the log;
   those with <command>Log.WARNING</> or <command>Log.ERROR</>
   urgency are also printed on the system console.
   The <parameter>source</> parameter is used to label the logged
   message; it is either an object or
   a class. If <parameter>source</>
   is <command>null</>, the current thread's name is used.
   The <parameter>message</> parameter is the message that is to
   be logged;
   it should either be a string or
   a <classname>java.lang.Throwable</> (the common superclass of all
   exceptions and errors). If you pass a <classname>Throwable</>, its
   stack trace is logged.
  </para>
  <para>
   Assuming that the below example occurs in the implementation for the
   <classname>FooPlugin</> class, the text
   <quote>[notice] FooPlugin: loading foo.dat...</> will be appended to
   the activity log:
  </para>
  <screen>Log.log(Log.NOTICE,this,"loading foo.dat...");</>
 </sect1>
 <sect1 id=plugin-editbus><title>The EditBus</>
  <para>
   The EditBus is a message passing system. Any number of components
   can be connected to the bus. Each component can send messages, as
   well as receive them.
  </para>
  <para>
   jEdit itself sends various messages to the bus - buffers being opened
   and closed, and so on. Plugins can also define their own message types
   to communicate with each other. The jEdit core only includes a small
   set of messages that are meant to be sent by jEdit itself only;
   the EditBus plugin includes a wider range of messages that can be
   used for inter-plugin communication. Get the EditBus plugin from
   <ulink url="http://www.icg-online.de/jedit">http://www.icg-online.de/jedit</>.
  </para>
  <para>
   Each message type is a subclass of <classname>EBMessage</>.
   All messages included with jEdit live in the
   <classname>org.gjt.sp.jedit.msg</> package.
   Because messages are full-fledged objects, they can carry any type of
   information.
  </para>
  <indexterm><primary>interface</><secondary>EBComponent</></indexterm>
  <bridgehead renderas=sect3>EBComponent interface</>
  <programlisting>public interface EBComponent
{
        public void handleMessage(EBMessage msg);
}</programlisting>
  <para>
   Each component on the bus must implement this interface. When a message
   is sent to the bus, the <function>handleMessage()</> method of each
   component is called in turn. Typically, this method will check if the
   message is of a known type using <function>instanceof</>, and take
   appropriate action.
  </para>
  <indexterm><primary>class</><secondary>EditBus</></indexterm>
  <indexterm><primary>method</><secondary>addToBus() of EditBus class</></indexterm>
  <bridgehead renderas=sect3>EditBus.addToBus() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EditBus;</>
   <funcprototype>
    <funcdef>public static void <function>addToBus</></funcdef>
    <paramdef>EBComponent <parameter>comp</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method adds the specified component to the bus. It will now
   receive all messages sent to the bus. Note that to avoid memory
   leaks, you must remember to remove components from the bus when
   they are no longer needed.
  </para>
  <indexterm><primary>method</><secondary>removeFromBus() of EditBus class</></indexterm>
  <bridgehead renderas=sect3>EditBus.removeFromBus() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EditBus;</>
   <funcprototype>
    <funcdef>public static void <function>removeFromBus</></funcdef>
    <paramdef>EBComponent <parameter>comp</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method removes the specified component from the bus, hence it
   will no longer receive any messages.
  </para>
  <indexterm><primary>class</><secondary>EBPlugin</></indexterm>
  <bridgehead renderas=sect3>EBPlugin class</>
  <programlisting>public abstract class EBPlugin extends EditPlugin
implements EBComponent
{
        public void handleMessage(EBMessage msg);
}</programlisting>
  <para>
   The <classname>EBPlugin</> class is identical to <classname>EditPlugin</>,
   except that the plugin is automatically added to the bus. If your
   plugin needs to receive messages, you can subclass <classname>EBPlugin</>.
  </para>
  <indexterm><primary>class</><secondary>EBMessage</></indexterm>
  <bridgehead renderas=sect3>EBMessage interface</>
  <programlisting>public abstract class EBMessage
{
        public EBMessage(EBComponent source);
        public EBComponent getSource();
        public void veto();
        public boolean isVetoed();
}</programlisting>
  <para>
   The <classname>org.gjt.sp.jedit.EBMessage</> class is the common
   superclass of all
   EditBus messages.
   Most methods in this class should be self-explanatory, except
   for the vetoing methods. Here is how it works; once you
   <function>veto()</> a message, it will not propogate further
   along the bus. The <function>isVetoed()</> method returns if the
   method has already been vetoed.
  </para>
  <para>
   The vetoing system is useful for messages that request some action
   to be taken; if some component on the bus can perform the action,
   it calls <function>veto()</>. The sender will then
   check the return value of <function>isVetoed()</> and display an
   error message
   if it is false (meaning no-one
   called <function>veto()</>).
  </para>
  <indexterm><primary>method</><secondary>send() of EditBus class</></indexterm>
  <bridgehead renderas=sect3>EditBus.send() method</>
  <funcsynopsis>
   <funcsynopsisinfo>import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;</>
   <funcprototype>
    <funcdef>public static void <function>send</></funcdef>
    <paramdef>EBMessage <parameter>msg</></paramdef>
   </funcprototype>
  </funcsynopsis>
  <para>
   This method sends the specified message to the
   bus (ie, it calls the <function>handleMessage()</> method of each
   component). Plugins should never send jEdit core messages (BufferUpdate,
   ViewUpdate, etc) directly; only send messages intended to be sent
   from plugins, for example the messages included in the EditBus plugin.
  </para>
  <sect2><title>BufferUpdate Message</>
   <para>
    This message is sent by jEdit when a buffer-related update occurs.
    The <function>getBuffer()</> method of the
    <classname>BufferUpdate</>
    class returns the buffer involved. The <function>getWhat()</> method
    returns one of the following:
   </para>
   <itemizedlist><listitem><para><command>BufferUpdate.CREATED</> - a
   new buffer has been created</para></listitem>
   <listitem><para><command>BufferUpdate.LOADING</> - a
   buffer is being loaded from disk</para></listitem>
   <listitem><para><command>BufferUpdate.DIRTY_CHANGED</> - the
   <quote>dirty</> flag has changed; either the buffer has been saved, or
   some changes have been made</para></listitem>
   <listitem><para><command>BufferUpdate.MARKERS_CHANGED</> - a marker has
   been added or removed</para></listitem>
   <listitem><para><command>BufferUpdate.MODE_CHANGED</> - the buffer's
   edit mode has changed</para></listitem>
   <listitem><para><command>BufferUpdate.SAVING</> - a buffer is about to
   be saved</para></listitem>
   <listitem><para><command>BufferUpdate.CLOSED</> - a buffer has been
   closed</para></listitem>
   </itemizedlist>
  </sect2>
  <sect2><title>EditorExiting Message</>
   <para>
    This message is sent by jEdit just before it exits.
    Hence, it is similar to the
    <function>stop()</> method of a plugin, but it is not limited
    to plugins.
   </para>
  </sect2>
  <sect2><title>EditorStarted Message</>
   <para>
    This message is sent by jEdit after it has finished starting, but
    before the initial view is created. Hence, it is similar to the
    <function>start()</> method of a plugin, but it is not limited
    to plugins.
   </para>
  </sect2>
  <sect2><title>MacrosChanged Message</>
   <indexterm><primary>Macros menu</></>
   <para>
    This message is sent by jEdit when the list of available macros changes.
    Its main use is to keep the <guimenu>Macros</> menu up to date;
    plugins will
    almost never need to handle this message.
   </para>
  </sect2>
  <sect2><title>PropertiesChanged Message</>
   <indexterm><primary>Utilities menu</></>
   <indexterm><primary>Global Options command</></>
   <para>
    This message is sent by jEdit after the
    <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
    dialog box is closed; your plugin should reload any
    editable settings when it receives this message.
   </para>
  </sect2>
  <sect2><title>SearchSettingsChanged Message</>
   <para>
    This message is sent by jEdit when search and replace flags (ignore case,
    regular expression, multiple file search) are changed. Its main
    use is to keepe buttons on a view's tool bar up to date; plugins will
    almost never need to handle this message.
   </para>
  </sect2>
  <sect2><title>ViewUpdate Message</>
   <para>
    This message is sent by jEdit when a view-related update occurs.
    The <function>getView()</> method of the
    <classname>BufferView</>
    class returns the view involved. The <function>getWhat()</> method
    returns one of the following:
   </para>
   <itemizedlist><listitem><para><command>ViewUpdate.CREATED</> - a
   new view has been created</para></listitem>
   <itemizedlist><listitem><para><command>ViewUpdate.TEXTAREA_CREATED</> - a
   new text area has been created - this message is sent when the view
   is split. The <function>getTextArea()</> method returns the new text
   area</para></listitem>
   <listitem><para><command>ViewUpdate.BUFFER_CHANGED</> - a view
   is now editing a different buffer</para></listitem>
   <listitem><para><command>ViewUpdate.CLOSED</> - a view has been
   closed</para></listitem>
   </itemizedlist>
  </sect2>
 </sect1>
</chapter>

<appendix id=cli-usage><title>Command Line Usage</>
 <para>
  When jEdit is started, it opens any files specified on the
  command line, and parses any specified the options. An option is a command
  line argument that begins with <quote>-</>. If you actually want to
  open a file
  whose name begins with <quote>-</>, specify <quote>- -</> on
  the command line before the file name. The <quote>- -</>
  switch makes jEdit ignore any remaining command line switches
  and interpret them as file names.
 </para>
 <indexterm><primary>moving the caret</>
 <secondary>to a marker</></indexterm>
 <indexterm><primary>moving the caret</><secondary>
    to a line number</></indexterm>
 <indexterm><primary>markers</></indexterm>
 <para>
  If a file name contains the hash (<quote>#</>) character, the
  remainder of the file name after the hash will be the name of
  the marker to move the caret to. If the first character of the
  marker name is a plus sign (<quote>+</>) the remainder is treated as a
  line number to move the caret to.
 </para>
 <indexterm><primary>command line</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-version</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-usage</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-nosettings</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-settings</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-session</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-noserver</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-server</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-wait</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-quit</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-nosessions</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-nosplash</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-readonly</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>-reuseview</></indexterm>
 <indexterm><primary>command line switches</>
 <secondary>--</></indexterm>
 <indexterm><primary>moving the caret</>
 <secondary>to a line number</></indexterm>
 <table><title>Table of command line switches</>
  <tgroup cols=2>
   <colspec colnum=1 colwidth=1.5in>
   <thead>
    <row><entry>Switch</><entry>Effect</></row>
   </thead>
   <tbody>
    <row>
     <entry>-noserver</>
     <entry>Disables the edit server. Does not attempt to
     connect to the server, and does not start one either.
     Can be used to force another instance of jEdit to start
     if one is already running.</entry>
    </row>
    <row>
     <entry>-nosession</>
     <entry>jEdit will not attempt to load
     a saved session. Session saving can be
     disabled permanently in the <guimenu>Utilities</>&gt;<guimenuitem>Global Options</>
     dialog box; see <xref linkend=global-opts>. Has no effect when connecting to
     another instance via the edit server.</entry>
    </row>
    <row>
     <entry>-nosettings</>
     <entry>Starts jEdit without loading the user-specific settings
     from <filename>$HOME/.jedit</>. This can be used if the
     user-specific settings are corrupt, or if a plugin installed
     in your plugins directory is causing problems. Has no effect
     when connecting to another instance via the edit server.</entry>
    </row>
    <row>
     <entry>-nosplash</>
     <entry>Starts jEdit without displaying the splash screen. This has
     several uses; first of all, if you start jEdit from your
     <filename>.xinitrc</> or whatever on Unix, it might be undesirable
     for the splash screen to appear every time you log in. Another
     reason this might be used is if you want jEdit to start slightly
     faster (not much faster; about half a second). Has no effect
     when connecting to another instance via the edit server.</entry>
    </row>
    <row>
     <entry>-readonly</>
     <entry>Opens all files specified on the command line read only.</>
    </row>
    <row>
     <entry>-server=<replaceable>name</></entry>
     <entry>Stores the server port info in the file named <replaceable>name</>,
     rather than the default <filename>server</> (file names for this
     parameter are relative to the settings directory, <filename>$HOME/.jedit</>
     by default).
     Can be used to start more than one instance of jEdit.</entry>
    </row>
    <row>
     <entry>-session=<replaceable>name</></entry>
     <entry>Loads a previously-saved session from
     <filename>$HOME/.jedit/sessions/<replaceable>name</></filename>.
     Sessions can be saved with the <guimenu>File</>&gt;<guimenuitem>Save
     Session</> command; see <xref linkend=sessions> for details.
     </entry>
    </row>
    <row>
     <entry>-settings=<replaceable>dir</></entry>
     <entry>Loads and saves the user-specific settings from
     the directory named <replaceable>dir</>, instead of the
     default <filename>$HOME/.jedit</>. <replaceable>dir</> will
     be created if it does not exist. Has no effect
     when connecting to another instance via the edit server.</entry>
    </row>
    <row>
     <entry>-reuseview</>
     <entry>Only valid when connecting to another instance. When this
     switch is specified, instead of
     creating a new view, jEdit will open the files in the first existing
     view.</entry>
    </row>
    <row>
     <entry>-usage</>
     <entry>Prints a brief command line usage message and exits.
     This is also shown if an invalid switch was specified.</>
    </row>
    <row>
     <entry>-version</>
     <entry>Prints the jEdit version number and exists.</>
    </row>
    <row>
     <entry>- -</>
     <entry>Specifies the end of the command line switches. Further
     parameters are treated as file names, even if they begin with
     a dash. Can be used to open files whose names start with a
     dash, and so on.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</appendix>

<appendix id=regexps><title>Regular Expressions</>
 <indexterm><primary>regular expressions</></indexterm>
 <para>
  jEdit uses regular expressions to implement inexact search and replace.
  A regular expression consists of a character string where some
  characters are given special meaning with regard to pattern matching.
 </para>
 <sect1 id=regexps-supported><title>Supported Syntax</>
  <para>
   Within a regular expression, the following characters have special meaning:
  </para>
  <itemizedlist>
   <listitem><para><emphasis>Positional Operators</></para>
    <itemizedlist>
     <listitem><para><command>^</> matches at the beginning of a line</></listitem>
     <listitem><para><command>$</> matches at the end of a line</></listitem>
     <listitem><para><command>\A</> matches the start of the entire string</></listitem>
     <listitem><para><command>\Z</> matches the end of the entire string</></listitem>
    </itemizedlist>
   </listitem>
   <listitem><para><emphasis>One-Character Operators</></para>
    <itemizedlist>
     <listitem><para><command>.</> matches any single character</></listitem>
     <listitem><para><command>\d</> matches any decimal digit</></listitem>
     <listitem><para><command>\D</> matches any non-digit</></listitem>
     <listitem><para><command>\n</> matches a newline character</></listitem>
     <listitem><para><command>\r</> matches a return character</></listitem>
     <listitem><para><command>\s</> matches any whitespace character</></listitem>
     <listitem><para><command>\S</> matches any non-whitespace character</></listitem>
     <listitem><para><command>\t</> matches a horizontal tab character</></listitem>
     <listitem><para><command>\w</> matches any word (alphanumeric) character</></listitem>
     <listitem><para><command>\W</> matches any non-word (alphanumeric)
     character</></listitem>
     <listitem><para><command>\<replaceable>x</></command> matches the
     character <replaceable>x</>, if <replaceable>x</> is not one of the above
     listed escape sequences.</></listitem>
    </itemizedlist>
   </listitem>
   <listitem><para><emphasis>Character Class Operator</></para>
    <itemizedlist>
     <listitem><para><command>[<replaceable>abc</>]</command> matches any character in
     the set <replaceable>a</>, <replaceable>b</> or
     <replaceable>c</></para></listitem>
     <listitem><para><command>[^<replaceable>abc</>]</command> matches any character not
     in the set <replaceable>a</>, <replaceable>b</> or
     <replaceable>c</></para></listitem>
     <listitem><para><command>[<replaceable>a-z</>]</command> matches any character in the
     range <replaceable>a</> to <replaceable>z</>, inclusive.
     A leading or trailing dash will be interpreted
     literally.</para></listitem>
    </itemizedlist>
    <para>
     Within a character class expression, the following sequences have special meaning:
     <itemizedlist>
      <listitem><para><command>[:alnum:]</> Any alphanumeric
      character</para></listitem>
      <listitem><para><command>[:alpha:]</> Any alphabetical character</para></listitem>
      <listitem><para><command>[:blank:]</> A space or horizontal tab</para></listitem>
      <listitem><para><command>[:cntrl:]</> A control character</para></listitem>
      <listitem><para><command>[:digit:]</> A decimal digit</para></listitem>
      <listitem><para><command>[:graph:]</> A non-space, non-control character</para></listitem>
      <listitem><para><command>[:lower:]</> A lowercase letter</para></listitem>
      <listitem><para><command>[:print:]</> Same as graph, but also space and tab</para></listitem>
      <listitem><para><command>[:punct:]</> A punctuation character</para></listitem>
      <listitem><para><command>[:space:]</> Any whitespace character, including newline and return</para></listitem>
      <listitem><para><command>[:upper:]</> An uppercase letter</para></listitem>
      <listitem><para><command>[:xdigit:]</> A valid hexadecimal digit</para></listitem>
     </itemizedlist>
    </para>
   </listitem>
   <listitem><para><emphasis>Subexpressions and Backreferences</></para>
    <itemizedlist>
     <listitem><para><command>(<replaceable>abc</>)</> matches whatever the expression
     <replaceable>abc</> would match, and saves it as a subexpression.
     Also used for grouping.</para></listitem>
     <listitem><para><command>(?:<replaceable>...</>)</> pure grouping operator, does not
     save contents</para></listitem>
     <listitem><para><command>(?#<replaceable>...</>)</> embedded comment, ignored by
     engine</para></listitem>
     <listitem><para><command>\<replaceable>n</></> where 0 &lt; <replaceable>n</> &lt; 10,
     matches the same thing the <replaceable>n</>th
     subexpression matched.</para></listitem>
    </itemizedlist>
   </listitem>
   <listitem><para><emphasis>Branching (Alternation) Operator</></para>
    <itemizedlist>
     <listitem><para><command><replaceable>a</>|<replaceable>b</></command> matches
     whatever the expression <replaceable>a</> would match, or whatever
     the expression <replaceable>b</> would match.</para></listitem>
    </itemizedlist>
   </listitem>
   <listitem><para><emphasis>Repeating Operators</></para>
    <para>
     These symbols operate on the previous atomic expression.
    </para>
    <itemizedlist>
     <listitem><para><command>?</> matches the preceding expression or the
     null string</para></listitem>
     <listitem><para><command>*</> matches the null string or any number of repetitions
     of the preceding expression</para></listitem>
     <listitem><para><command>+</> matches one or more repetitions of the preceding
     expression</para></listitem>
     <listitem><para><command>{<replaceable>m</>}</> matches exactly <replaceable>m</>
     repetitions of the one-character expression</para></listitem>
     <listitem><para><command>{<replaceable>m</>,<replaceable>n</>}</> matches between
     <replaceable>m</> and <replaceable>n</> repetitions of the preceding
     expression, inclusive</para></listitem>
     <listitem><para><command>{<replaceable>m</>,}</> matches <replaceable>m</> or more
     repetitions of the preceding expression</para></listitem>
    </itemizedlist>
   </listitem>
   <listitem><para><emphasis>Stingy (Minimal) Matching</></para>
    <para>
     If a repeating operator (above) is immediately followed by a
     <command>?</>, the repeating operator will stop at the smallest
     number of repetitions that can complete the rest of the match.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 id=regexps-unsupported><title>Unsupported Syntax</>
  <para>
   Some flavors of regular expression utilities support additional escape
   sequences, and this is not meant to be an exhaustive list.  In the
   future, <command>gnu.regexp</> may support some or all of the
   following:
   <itemizedlist>
    <listitem><para><command>(?=<replaceable>...</>)</> positive lookahead operator (Perl5)</para></listitem>
    <listitem><para><command>(?!<replaceable>...</>)</> negative lookahead operator (Perl5)</para></listitem>
    <listitem><para><command>(?<replaceable>mods</>)</> inlined compilation/execution modifiers (Perl5)</para></listitem>
    <listitem><para><command>\G</> end of previous match (Perl5)</para></listitem>
    <listitem><para><command>\b</> word break positional anchor (Perl5)</para></listitem>
    <listitem><para><command>\B</> non-word break positional anchor (Perl5)</para></listitem>
    <listitem><para><command>\&lt;</> start of word positional anchor (egrep)</para></listitem>
    <listitem><para><command>\&gt;</> end of word positional anchor (egrep)</para></listitem>
    <listitem><para><command>[.<replaceable>symbol</>.]</> collating symbol in class expression (POSIX)</para></listitem>
    <listitem><para><command>[=<replaceable>class</>=]</> equivalence class in class expression (POSIX)</para></listitem>
   </itemizedlist>
  </para>
 </sect1>
</appendix>

<appendix id=globs><title>Glob Patterns</>
 <para>
  jEdit uses glob patterns similar to those in MS-DOS and the various
  Unix shells to implement file name filters in the <guimenuitem>Open File</> and
  <guimenuitem>Save As</> dialog boxes.
  Glob patterns resemble regular expressions somewhat,
  but have a much simpler
  syntax. The following character sequences have special meaning within a glob
  pattern:
 </para>
 <itemizedlist>
  <listitem><para><command>?</> matches any one character</para></listitem>
  <listitem><para><command>*</> matches any number of characters</para></listitem>
  <listitem><para><command>{<replaceable>a</>,<replaceable>b</>,<replaceable>c</>}</>
  matches any one of <replaceable>a</>, <replaceable>b</> or
  <replaceable>c</></para></listitem>
 </itemizedlist>
 <para>
  Character class expressions (<command>[abc]</>, etc) are supported in globs
  and behave exactly like regular expression character classes; see
  <xref linkend=regexps> for details.
 </para>
</appendix>

<appendix id=jedit-history><title>History of jEdit</>
 <para>
  Open Source projects are often started with the author <quote>scratching
  an itch</>; for example, some programmer itching for a good mail client
  might write one. jEdit, however, started as more of an experimental
  hack. I never intended it to be useful; its growth and popularity was
  completely unexpected to me.
 </para>
 <bridgehead renderas=sect2>Early Efforts</>
 <para>
  One can say that jEdit started as early as 1996.
  My first effort at writing an editor, and in fact my first effort
  at writing a real Java program, was an application called
  <application>JavaJot</>. The source code totalled to about 5 kilobytes;
  JavaJot wasn't about to compete with emacs any time soon. I posted
  JavaJot to my homepage, but didn't get a single e-mail about it (no
  surprise either)
 </para>
 <para>
  Nearly a year later (late 1997/early 1998) when I got a PC, I started
  hacking in Java 1.1. I downloaded several Java 1.1 applications, to see how
  the new features be used. One that particularly
  impressed me was John Jensen's <application>TextEdit</>.
  It's most interesting feature was a plugin system; it could
  load external JAR files to extend the editor.
  It was a neat idea, but TextEdit didn't take it far
  enough; for example, plugins were limited to filtering the selected text,
  and couldn't do much else.
 </para>
 <para>
  So soon after seeing TextEdit, I began coding <quote>JEdit</> (note
  that the first character was capitalized, unlike today's
  <quote>jEdit</>). I implemented a plugin system similar to TextEdit's,
  and added many other features that TextEdit lacked, such as
  multiple document support. JEdit was never released to the public;
  I felt that there were so many other trivial Java text editors out
  there, that JEdit wouldn't make much of a difference.
 </para>
 <para>
  One of the reasons JEdit remained trivial was that at the time,
  the AWT sucked. Writing complex GUIs was too hard and often one had
  to write their own components, from scratch, to go beyond the very
  basic capabilities offered by the AWT. So when Swing 1.0 was released,
  promising rich, lightweight, customizable components,
  I immediately downloaded it. I was impressed. So impressed that I
  wrote an another editor, this time using Swing. I called it JE. It went
  far beyond the original JEdit in features, and was better than many
  Java editors available at the time.
 </para>
 <para>
  However, I never released JE either; because I didn't know Swing very
  well at the time, it had many flaws; for example, the go to line function
  parsed the text area for
  line break (\n) characters, instead of using the much faster
  Swing element map.
 </para>
 <bridgehead renderas=sect2>Third Time Lucky</>
 <para>
  What I started coding next became the nowadays jEdit. I copied
  the <quote>good</> bits from JE, such as the plugin system, and
  rewrote the rest from scratch. I also released early and often. After I
  implemented file loading, saving, and several other fundamental
  features, I released the first jEdit with a <quote>version number</>;
  I called it jEdit 0.2. After version 0.2, I made a few more
  0.x releases which added some more basic
  functionality, such as printing and search and replace.
 </para>
 <bridgehead renderas=sect2>jEdit 1.0 and 1.1</>
 <para>
  In September 1998, after only about a month of development, jEdit 1.0 was
  released. At this time, I never
  intended it to be anything more than a trivial text editor.
  jEdit 1.1 was released approximately one month
  later, but it only added a few minor features, and was still rather
  limited.
 </para>
 <bridgehead renderas=sect2>jEdit 1.2</>
 <para>
  After releasing jEdit 1.1, I more-or-less stopped developing it, not
  sure what to do next. But then
  as a quick hack,
  Tal Davidson
  (author of JStyle and Artistic Style) wrote a simple syntax highlighting
  backend parser
  that he called <application>JSTokenMarker</>.
  After he sent it to me, I started work on jEdit 1.2 immediately.
  1.2pre1 was a cleanup release, and 1.2pre2 integrated his code.
  It was buggy and slow, but it changed jEdit forever; it was no longer
  just a toy.
 </para>
 <para>
  I continued enhancing JSTokenMarker throughout the 1.2 pre-releases.
  At version 1.2pre7, it was pretty stable, and it supported
  HTML and various other file types. Unfortunately, it was too slow and
  wasn't very well implemented (it was a quick hack, after all). So
  in jEdit 1.2pre8, I scrapped Tal's original
  code and wrote my own system, implementing it more
  carefully. It was a total rewrite, and in fact none of Tal's original
  code remains, but the JSTokenMarker legacy
  lives on; the main syntax parser class is named <classname>TokenMarker</>,
  and many other class and method names are similar or exactly the same
  as in Tal's original implementation - <function>markTokens()</>, and so on.
 </para>
 <para>
  By the time jEdit 1.2 was released, I began using it as my primary
  text editor. Because of this, jEdit 1.2 was probably the
  most significant release ever.
  Version 1.1 was just a trivial hack I wrote for fun. Then, in a
  little less than a month, it became a serious tool.
 </para>
 <bridgehead renderas=sect2>After 1.2</>
 <para>
  Subsequent jEdit versions added many more features and enhancements.
  jEdit 1.2 seems primitive in comparison to the latest releases.
  But nothing really notable has happened since 1.2 was released; jEdit
  has more or less stayed on the same path.
 </para>
</appendix>

&index.sgml;

</book>
